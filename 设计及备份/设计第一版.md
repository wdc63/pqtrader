# 基于股市数据API的量化交易框架设计文档

## 目录

1. [系统概述](#1-系统概述)
2. [核心设计理念](#2-核心设计理念)
3. [系统架构设计](#3-系统架构设计)
4. [核心模块详细设计](#4-核心模块详细设计)
5. [数据层设计](#5-数据层设计)
6. [交易撮合机制](#6-交易撮合机制)
7. [时间与调度系统](#7-时间与调度系统)
8. [状态管理与持久化](#8-状态管理与持久化)
9. [回测与实盘模式](#9-回测与实盘模式)
10. [可视化与报告](#10-可视化与报告)
11. [扩展性设计](#11-扩展性设计)
12. [实施路线图](#12-实施路线图)

---

## 1. 系统概述

### 1.1 设计目标

构建一个**轻量级、高度解耦、易于扩展**的量化交易框架，具备以下特点：

- **数据实时获取**：无需预下载历史数据，基于API实时获取
- **回测/实盘统一**：同一套代码可无缝切换回测与实盘模式
- **事件驱动架构**：清晰的生命周期钩子（初始化、盘前、盘中、盘后）
- **灵活撮合机制**：支持多种撮合模式（Tick五档、限价单、市价单）
- **智能缓存策略**：最小化API调用，优化性能
- **状态可持久化**：支持暂停/恢复，便于长期运行
- **可视化友好**：内置可视化与报告生成

### 1.2 核心差异化特性

相比现有框架（如Zipline、Backtrader、QFF），本框架的核心差异：

| 特性 | 本框架 | Zipline | QFF |
|------|--------|---------|-----|
| 数据获取 | API实时获取 | 预下载Bundle | MongoDB预存 |
| 撮合机制 | Tick五档+滑点 | 简化撮合 | 分钟/日线撮合 |
| 缓存策略 | 智能分层缓存 | 全量内存 | MongoDB查询 |
| 扩展性 | 插件化架构 | 耦合较强 | 中等 |
| 实盘支持 | 原生支持 | 需改造 | 支持模拟盘 |

---

## 2. 核心设计理念

### 2.1 架构原则

1. **数据与策略解耦**
   - 策略层不直接调用API，通过数据接口层抽象
   - 数据接口层可替换为任意数据源（API、本地文件、数据库）

2. **事件驱动**
   - 框架核心是事件调度器
   - 策略通过注册回调函数响应事件

3. **可配置优先**
   - 所有行为通过配置文件控制
   - 默认配置满足常见场景，高级用户可深度定制

4. **最小惊讶原则**
   - API设计直观，符合直觉
   - 默认行为安全（如T+1自动处理）

### 2.2 分层架构

```
┌─────────────────────────────────────────┐
│         策略层 (Strategy Layer)          │
│  - 用户策略代码                          │
│  - 生命周期钩子实现                       │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│       框架核心层 (Core Framework)        │
│  - 事件调度器 (Event Scheduler)          │
│  - 时间管理器 (Time Manager)             │
│  - 账户管理器 (Account Manager)          │
│  - 订单管理器 (Order Manager)            │
│  - 撮合引擎 (Matching Engine)            │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      数据接口层 (Data Interface)         │
│  - 数据适配器 (Data Adapter)             │
│  - 缓存管理器 (Cache Manager)            │
│  - API客户端封装                         │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│        数据源层 (Data Source)            │
│  - Stock API SDK                        │
│  - 本地文件 (可选)                       │
│  - 其他数据源 (可扩展)                    │
└─────────────────────────────────────────┘
```

---

## 3. 系统架构设计

### 3.1 整体架构图

```
┌───────────────────────────────────────────────────────────┐
│                       用户策略代码                         │
│  class MyStrategy:                                        │
│      def initialize(context):                             │
│      def before_trading(context, data):                   │
│      def handle_bar(context, data):                       │
│      def after_trading(context, data):                    │
└───────────────────────────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────┐
│                    事件调度器核心                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ Time        │  │ Event       │  │ Lifecycle   │      │
│  │ Manager     │→ │ Dispatcher  │→ │ Hooks       │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└───────────────────────────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────┐
│                    核心业务模块                            │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐     │
│  │ Account      │ │ Order        │ │ Matching     │     │
│  │ Manager      │ │ Manager      │ │ Engine       │     │
│  └──────────────┘ └──────────────┘ └──────────────┘     │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐     │
│  │ Position     │ │ Performance  │ │ Risk         │     │
│  │ Manager      │ │ Analyzer     │ │ Manager      │     │
│  └──────────────┘ └──────────────┘ └──────────────┘     │
└───────────────────────────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────┐
│                    数据服务层                              │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐     │
│  │ Data         │ │ Cache        │ │ API          │     │
│  │ Adapter      │ │ Manager      │ │ Client       │     │
│  └──────────────┘ └──────────────┘ └──────────────┘     │
└───────────────────────────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────┐
│                 Stock API SDK / 本地存储                   │
└───────────────────────────────────────────────────────────┘
```

### 3.2 目录结构

```
quant_framework/
├── core/                      # 核心框架
│   ├── __init__.py
│   ├── context.py            # 全局上下文对象
│   ├── engine.py             # 主引擎
│   ├── scheduler.py          # 事件调度器
│   ├── time_manager.py       # 时间管理器
│   ├── lifecycle.py          # 生命周期管理
│   └── config.py             # 配置管理
│
├── trading/                   # 交易核心
│   ├── __init__.py
│   ├── account.py            # 账户管理
│   ├── order.py              # 订单对象
│   ├── order_manager.py      # 订单管理器
│   ├── position.py           # 持仓对象
│   ├── position_manager.py   # 持仓管理器
│   ├── matching_engine.py    # 撮合引擎
│   ├── commission.py         # 手续费计算
│   └── slippage.py           # 滑点模型
│
├── data/                      # 数据层
│   ├── __init__.py
│   ├── adapter.py            # 数据适配器基类
│   ├── api_adapter.py        # API数据适配器
│   ├── cache/                # 缓存模块
│   │   ├── __init__.py
│   │   ├── base.py           # 缓存基类
│   │   ├── calendar_cache.py # 交易日历缓存
│   │   ├── tick_cache.py     # Tick数据缓存
│   │   └── kline_cache.py    # K线数据缓存
│   └── providers/            # 数据提供者
│       ├── __init__.py
│       ├── stock_api.py      # Stock API封装
│       └── local_file.py     # 本地文件(可选)
│
├── strategy/                  # 策略相关
│   ├── __init__.py
│   ├── base.py               # 策略基类
│   ├── context.py            # 策略上下文
│   └── api.py                # 策略API
│
├── analysis/                  # 分析模块
│   ├── __init__.py
│   ├── performance.py        # 绩效分析
│   ├── risk.py               # 风险分析
│   ├── report.py             # 报告生成
│   └── visualizer.py         # 可视化
│
├── utils/                     # 工具模块
│   ├── __init__.py
│   ├── logger.py             # 日志工具
│   ├── serializer.py         # 序列化工具
│   ├── validator.py          # 参数验证
│   └── helpers.py            # 辅助函数
│
├── plugins/                   # 插件系统
│   ├── __init__.py
│   ├── base.py               # 插件基类
│   └── examples/             # 示例插件
│
├── configs/                   # 配置文件
│   ├── default.yaml          # 默认配置
│   ├── backtest.yaml         # 回测配置
│   └── live.yaml             # 实盘配置
│
├── examples/                  # 示例策略
│   ├── simple_ma.py          # 简单均线策略
│   ├── factor_strategy.py    # 因子策略
│   └── README.md
│
├── tests/                     # 测试
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── web/                       # Web界面(可选)
│   ├── app.py                # Flask/FastAPI应用
│   ├── templates/            # HTML模板
│   └── static/               # 静态资源
│
├── setup.py
├── requirements.txt
└── README.md
```

---

## 4. 核心模块详细设计

### 4.1 Context（全局上下文）

#### 4.1.1 设计目标

提供一个全局单例对象，存储回测/实盘运行中的所有状态信息。

#### 4.1.2 核心属性

```python
# core/context.py

from datetime import datetime
from typing import Dict, Any, Optional
from dataclasses import dataclass, field

@dataclass
class Context:
    """全局上下文对象"""
    
    # 基础信息
    mode: str = 'backtest'  # 'backtest' 或 'live'
    strategy_name: str = ''
    start_date: str = ''
    end_date: str = ''
    current_dt: Optional[datetime] = None
    
    # 账户相关
    portfolio: Optional['Portfolio'] = None
    
    # 数据相关
    data_adapter: Optional['DataAdapter'] = None
    cache_manager: Optional['CacheManager'] = None
    
    # 订单与持仓
    order_manager: Optional['OrderManager'] = None
    position_manager: Optional['PositionManager'] = None
    
    # 配置
    config: Dict[str, Any] = field(default_factory=dict)
    
    # 用户自定义数据存储
    user_data: Dict[str, Any] = field(default_factory=dict)
    
    # 运行状态
    is_running: bool = False
    is_paused: bool = False
    
    # 性能追踪
    performance: Optional['Performance'] = None
    
    # 日志
    logger: Optional['Logger'] = None
    
    def __post_init__(self):
        """初始化后处理"""
        if self.current_dt is None:
            self.current_dt = datetime.now()
    
    def get(self, key: str, default: Any = None) -> Any:
        """获取用户自定义数据"""
        return self.user_data.get(key, default)
    
    def set(self, key: str, value: Any):
        """设置用户自定义数据"""
        self.user_data[key] = value
```

#### 4.1.3 使用示例

```python
# 在策略中访问
def handle_bar(context, data):
    # 获取当前时间
    current_time = context.current_dt
    
    # 获取账户信息
    cash = context.portfolio.cash
    
    # 自定义数据存储
    context.set('my_indicator', 0.5)
    indicator = context.get('my_indicator')
```

---

### 4.2 Engine（主引擎）

#### 4.2.1 职责

- 初始化所有核心组件
- 协调各模块运行
- 控制回测/实盘流程

#### 4.2.2 核心实现

```python
# core/engine.py

from typing import Type, Optional
import yaml
from .context import Context
from .scheduler import Scheduler
from .time_manager import TimeManager
from ..trading.account import Portfolio
from ..trading.order_manager import OrderManager
from ..trading.matching_engine import MatchingEngine
from ..data.adapter import DataAdapter
from ..data.cache.cache_manager import CacheManager
from ..strategy.base import Strategy

class Engine:
    """框架主引擎"""
    
    def __init__(self, config_path: Optional[str] = None):
        # 加载配置
        self.config = self._load_config(config_path)
        
        # 初始化上下文
        self.context = Context(
            mode=self.config['mode'],
            config=self.config
        )
        
        # 初始化组件
        self._init_components()
    
    def _load_config(self, config_path: Optional[str]) -> dict:
        """加载配置文件"""
        if config_path is None:
            config_path = 'configs/default.yaml'
        
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        
        return config
    
    def _init_components(self):
        """初始化所有核心组件"""
        # 时间管理器
        self.time_manager = TimeManager(self.context)
        
        # 数据层
        self.cache_manager = CacheManager(self.config['cache'])
        self.data_adapter = DataAdapter.create(
            self.config['data'],
            self.cache_manager
        )
        
        # 账户
        self.context.portfolio = Portfolio(
            initial_cash=self.config['initial_cash']
        )
        
        # 订单与持仓
        self.context.order_manager = OrderManager(self.context)
        self.context.position_manager = PositionManager(self.context)
        
        # 撮合引擎
        self.matching_engine = MatchingEngine(
            self.context,
            self.config['matching']
        )
        
        # 调度器
        self.scheduler = Scheduler(
            self.context,
            self.time_manager,
            self.matching_engine
        )
        
        # 关联到context
        self.context.data_adapter = self.data_adapter
        self.context.cache_manager = self.cache_manager
    
    def run(self, strategy_class: Type[Strategy], **kwargs):
        """运行策略"""
        # 实例化策略
        strategy = strategy_class()
        
        # 注册生命周期钩子
        self.scheduler.register_strategy(strategy)
        
        # 设置时间范围
        self.context.start_date = kwargs.get('start_date', self.config['start_date'])
        self.context.end_date = kwargs.get('end_date', self.config['end_date'])
        
        # 启动调度器
        self.context.is_running = True
        self.scheduler.run()
    
    def pause(self):
        """暂停运行"""
        self.context.is_paused = True
        self._save_state()
    
    def resume(self, state_path: str):
        """从保存点恢复"""
        self._load_state(state_path)
        self.context.is_paused = False
        self.scheduler.run()
    
    def _save_state(self):
        """保存当前状态"""
        # 实现见第8章
        pass
    
    def _load_state(self, path: str):
        """加载状态"""
        # 实现见第8章
        pass
```

---

### 4.3 Scheduler（事件调度器）

#### 4.3.1 核心职责

- 管理时间序列的推进
- 在关键时间点触发生命周期钩子
- 协调撮合引擎执行

#### 4.3.2 生命周期事件

```python
# core/scheduler.py

from datetime import datetime, time, timedelta
from typing import Optional
from .context import Context
from .time_manager import TimeManager
from ..trading.matching_engine import MatchingEngine
from ..strategy.base import Strategy

class Scheduler:
    """事件调度器"""
    
    # 定义交易时段
    MORNING_START = time(9, 30)
    MORNING_END = time(11, 30)
    AFTERNOON_START = time(13, 0)
    AFTERNOON_END = time(15, 0)
    
    def __init__(
        self,
        context: Context,
        time_manager: TimeManager,
        matching_engine: MatchingEngine
    ):
        self.context = context
        self.time_manager = time_manager
        self.matching_engine = matching_engine
        self.strategy: Optional[Strategy] = None
        
        # 分钟频率的时间点列表
        self.minute_schedule = self._build_minute_schedule()
    
    def register_strategy(self, strategy: Strategy):
        """注册策略"""
        self.strategy = strategy
    
    def run(self):
        """主运行循环"""
        if self.context.mode == 'backtest':
            self._run_backtest()
        else:
            self._run_live()
    
    def _run_backtest(self):
        """回测模式运行"""
        # 获取交易日列表
        trading_days = self.time_manager.get_trading_days(
            self.context.start_date,
            self.context.end_date
        )
        
        # 调用初始化
        self._call_initialize()
        
        # 遍历每个交易日
        for current_date in trading_days:
            if not self.context.is_running or self.context.is_paused:
                break
            
            # 日级别回测
            if self.context.config['frequency'] == 'daily':
                self._run_daily_bar(current_date)
            
            # 分钟级别回测
            elif self.context.config['frequency'] == 'minute':
                self._run_minute_bars(current_date)
        
        # 调用结束钩子
        self._call_on_end()
    
    def _run_live(self):
        """实盘模式运行"""
        # 调用初始化
        self._call_initialize()
        
        while self.context.is_running:
            now = datetime.now()
            
            # 判断是否在交易时段
            if not self.time_manager.is_trading_time(now):
                self._sleep_until_next_event()
                continue
            
            # 判断当前应该执行什么事件
            if self._should_run_before_trading(now):
                self._call_before_trading(now)
            
            elif self._should_run_handle_bar(now):
                if self.context.config['frequency'] == 'daily':
                    self._call_handle_bar(now)
                elif self.context.config['frequency'] == 'minute':
                    self._call_handle_bar(now)
                    self.matching_engine.match_orders(now)
            
            elif self._should_run_after_trading(now):
                self._call_after_trading(now)
                self.matching_engine.settle()
            
            # 休眠到下一个事件点
            self._sleep_until_next_event()
    
    def _run_daily_bar(self, date: str):
        """执行单日回测（日频）"""
        # 设置当前时间为开盘时刻
        dt = datetime.strptime(f"{date} 09:30:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt
        
        # 盘前
        self._call_before_trading(dt)
        
        # 盘中（日频只调用一次）
        self._call_handle_bar(dt)
        
        # 撮合（使用收盘价）
        self.matching_engine.match_orders(dt)
        
        # 盘后
        dt_close = datetime.strptime(f"{date} 15:00:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_close
        self._call_after_trading(dt_close)
        
        # 结算
        self.matching_engine.settle()
    
    def _run_minute_bars(self, date: str):
        """执行单日回测（分钟频）"""
        # 盘前
        dt_before = datetime.strptime(f"{date} 09:25:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_before
        self._call_before_trading(dt_before)
        
        # 遍历分钟时间点
        for minute_str in self.minute_schedule:
            dt = datetime.strptime(f"{date} {minute_str}", "%Y-%m-%d %H:%M:%S")
            self.context.current_dt = dt
            
            # 调用handle_bar
            self._call_handle_bar(dt)
            
            # 撮合
            self.matching_engine.match_orders(dt)
            
            if self.context.is_paused:
                break
        
        # 盘后
        dt_after = datetime.strptime(f"{date} 15:00:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_after
        self._call_after_trading(dt_after)
        
        # 结算
        self.matching_engine.settle()
    
    def _build_minute_schedule(self) -> list:
        """构建分钟时间点列表"""
        schedule = []
        
        # 上午时段
        current = datetime.combine(datetime.today(), self.MORNING_START)
        end = datetime.combine(datetime.today(), self.MORNING_END)
        while current <= end:
            schedule.append(current.strftime("%H:%M:%S"))
            current += timedelta(minutes=1)
        
        # 下午时段
        current = datetime.combine(datetime.today(), self.AFTERNOON_START)
        end = datetime.combine(datetime.today(), self.AFTERNOON_END)
        while current <= end:
            schedule.append(current.strftime("%H:%M:%S"))
            current += timedelta(minutes=1)
        
        return schedule
    
    def _call_initialize(self):
        """调用初始化钩子"""
        if hasattr(self.strategy, 'initialize'):
            self.strategy.initialize(self.context)
    
    def _call_before_trading(self, dt: datetime):
        """调用盘前钩子"""
        if hasattr(self.strategy, 'before_trading'):
            data = self._get_data_proxy(dt)
            self.strategy.before_trading(self.context, data)
    
    def _call_handle_bar(self, dt: datetime):
        """调用盘中钩子"""
        if hasattr(self.strategy, 'handle_bar'):
            data = self._get_data_proxy(dt)
            self.strategy.handle_bar(self.context, data)
    
    def _call_after_trading(self, dt: datetime):
        """调用盘后钩子"""
        if hasattr(self.strategy, 'after_trading'):
            data = self._get_data_proxy(dt)
            self.strategy.after_trading(self.context, data)
    
    def _call_on_end(self):
        """调用结束钩子"""
        if hasattr(self.strategy, 'on_end'):
            self.strategy.on_end(self.context)
    
    def _get_data_proxy(self, dt: datetime):
        """获取数据代理对象"""
        from ..strategy.data_proxy import DataProxy
        return DataProxy(self.context, dt)
    
    def _should_run_before_trading(self, now: datetime) -> bool:
        """判断是否应该执行盘前"""
        # 实盘：在9:25执行
        return now.time() >= time(9, 25) and now.time() < time(9, 26)
    
    def _should_run_handle_bar(self, now: datetime) -> bool:
        """判断是否应该执行盘中"""
        current_time = now.time()
        
        # 日频：在开盘时执行
        if self.context.config['frequency'] == 'daily':
            return current_time >= self.MORNING_START and current_time < time(9, 31)
        
        # 分钟频：每分钟执行
        else:
            return (
                (self.MORNING_START <= current_time <= self.MORNING_END) or
                (self.AFTERNOON_START <= current_time <= self.AFTERNOON_END)
            )
    
    def _should_run_after_trading(self, now: datetime) -> bool:
        """判断是否应该执行盘后"""
        # 实盘：在15:01执行
        return now.time() >= time(15, 1) and now.time() < time(15, 2)
    
    def _sleep_until_next_event(self):
        """休眠到下一个事件点"""
        import time
        
        if self.context.config['frequency'] == 'minute':
            # 分钟频：休眠到下一分钟
            time.sleep(60 - datetime.now().second)
        else:
            # 日频：休眠5秒后再检查
            time.sleep(5)
```

---

### 4.4 TimeManager（时间管理器）

#### 4.4.1 职责

- 管理交易日历
- 判断交易时段
- 提供时间相关工具函数

#### 4.4.2 核心实现

```python
# core/time_manager.py

from datetime import datetime, date, time
from typing import List, Optional
from ..data.cache.calendar_cache import CalendarCache

class TimeManager:
    """时间管理器"""
    
    # 交易时段定义（可配置）
    MORNING_START = time(9, 30)
    MORNING_END = time(11, 30)
    AFTERNOON_START = time(13, 0)
    AFTERNOON_END = time(15, 0)
    
    def __init__(self, context):
        self.context = context
        self.calendar_cache = CalendarCache(context.data_adapter)
    
    def is_trading_day(self, dt: datetime) -> bool:
        """判断是否为交易日"""
        date_str = dt.strftime('%Y-%m-%d')
        return self.calendar_cache.is_trading_day(date_str)
    
    def is_trading_time(self, dt: datetime) -> bool:
        """判断是否在交易时段"""
        if not self.is_trading_day(dt):
            return False
        
        current_time = dt.time()
        return (
            (self.MORNING_START <= current_time <= self.MORNING_END) or
            (self.AFTERNOON_START <= current_time <= self.AFTERNOON_END)
        )
    
    def get_trading_days(
        self,
        start: str,
        end: str
    ) -> List[str]:
        """获取交易日列表"""
        return self.calendar_cache.get_trading_days(start, end)
    
    def get_previous_trading_day(
        self,
        dt: datetime,
        n: int = 1
    ) -> Optional[str]:
        """获取前N个交易日"""
        return self.calendar_cache.get_previous_trading_day(
            dt.strftime('%Y-%m-%d'),
            n
        )
    
    def get_next_trading_day(
        self,
        dt: datetime,
        n: int = 1
    ) -> Optional[str]:
        """获取后N个交易日"""
        return self.calendar_cache.get_next_trading_day(
            dt.strftime('%Y-%m-%d'),
            n
        )
```

---

## 5. 数据层设计

### 5.1 数据适配器（DataAdapter）

#### 5.1.1 设计目标

- 提供统一的数据访问接口
- 屏蔽底层数据源差异
- 支持多种数据源（API、本地文件、数据库）

#### 5.1.2 基类设计

```python
# data/adapter.py

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Union
from datetime import datetime

class DataAdapter(ABC):
    """数据适配器基类"""
    
    @abstractmethod
    def get_tick(
        self,
        code: Union[str, List[str]],
        dt: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """获取Tick数据"""
        pass
    
    @abstractmethod
    def get_kline(
        self,
        code: Union[str, List[str]],
        period: str,
        start: Optional[str] = None,
        end: Optional[str] = None,
        count: Optional[int] = None,
        adjust: str = 'none'
    ) -> Dict[str, List[Dict]]:
        """获取K线数据"""
        pass
    
    @abstractmethod
    def get_stock_list(
        self,
        typ: Optional[str] = None,
        date: Optional[str] = None
    ) -> List[Dict]:
        """获取股票列表"""
        pass
    
    @abstractmethod
    def get_valuation(
        self,
        code: Union[str, List[str]],
        date: Optional[str] = None
    ) -> Dict[str, Dict]:
        """获取估值数据"""
        pass
    
    @abstractmethod
    def get_fundamentals(
        self,
        code: Union[str, List[str]],
        n: int = 1,
        freq: str = 'q',
        ref_date: Optional[str] = None
    ) -> Dict[str, List[Dict]]:
        """获取财务数据"""
        pass
    
    @abstractmethod
    def is_suspended(
        self,
        code: Union[str, List[str]],
        date: Optional[str] = None
    ) -> List[Dict]:
        """判断停牌"""
        pass
    
    @abstractmethod
    def get_trading_days(
        self,
        start: str,
        end: str
    ) -> List[str]:
        """获取交易日历"""
        pass
    
    @abstractmethod
    def is_trading_day(self, date: str) -> bool:
        """判断是否为交易日"""
        pass
    
    @staticmethod
    def create(config: dict, cache_manager) -> 'DataAdapter':
        """工厂方法，根据配置创建适配器"""
        adapter_type = config.get('type', 'api')
        
        if adapter_type == 'api':
            from .api_adapter import APIDataAdapter
            return APIDataAdapter(config, cache_manager)
        elif adapter_type == 'local':
            from .local_adapter import LocalDataAdapter
            return LocalDataAdapter(config, cache_manager)
        else:
            raise ValueError(f"Unknown adapter type: {adapter_type}")
```

#### 5.1.3 API适配器实现

```python
# data/api_adapter.py

from typing import List, Dict, Any, Optional, Union
from datetime import datetime
from .adapter import DataAdapter
from .providers.stock_api import StockAPIClient

class APIDataAdapter(DataAdapter):
    """基于Stock API的数据适配器"""
    
    def __init__(self, config: dict, cache_manager):
        self.config = config
        self.cache_manager = cache_manager
        
        # 初始化API客户端
        self.client = StockAPIClient(
            base_url=config['base_url'],
            api_key=config['api_key'],
            timeout=config.get('timeout', 30)
        )
    
    def get_tick(
        self,
        code: Union[str, List[str]],
        dt: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """获取Tick数据"""
        # 先查缓存
        cache_key = f"tick_{code}_{dt}"
        cached = self.cache_manager.get_tick(cache_key)
        if cached is not None:
            return cached
        
        # API调用
        date_str = dt.strftime('%Y-%m-%d %H:%M:%S') if dt else None
        result = self.client.market.get_tick(code=code, date=date_str)
        
        # 写入缓存
        self.cache_manager.set_tick(cache_key, result)
        
        return result
    
    def get_kline(
        self,
        code: Union[str, List[str]],
        period: str,
        start: Optional[str] = None,
        end: Optional[str] = None,
        count: Optional[int] = None,
        adjust: str = 'none'
    ) -> Dict[str, List[Dict]]:
        """获取K线数据"""
        # 检查缓存
        cache_key = f"kline_{code}_{period}_{start}_{end}_{count}_{adjust}"
        cached = self.cache_manager.get_kline(cache_key)
        if cached is not None:
            return cached
        
        # API调用
        result = self.client.market.get_kline(
            code=code,
            period=period,
            begin_time=start,
            end_time=end,
            count=count,
            adjust=adjust
        )
        
        # 写入缓存
        self.cache_manager.set_kline(cache_key, result)
        
        return result
    
    def get_stock_list(
        self,
        typ: Optional[str] = None,
        date: Optional[str] = None
    ) -> List[Dict]:
        """获取股票列表"""
        # 股票列表变化不频繁，缓存时间较长
        cache_key = f"stock_list_{typ}_{date}"
        cached = self.cache_manager.get(cache_key)
        if cached is not None:
            return cached
        
        result = self.client.stock.get_stock_list(typ=typ, date=date)
        
        # 缓存24小时
        self.cache_manager.set(cache_key, result, ttl=86400)
        
        return result
    
    def get_valuation(
        self,
        code: Union[str, List[str]],
        date: Optional[str] = None
    ) -> Dict[str, Dict]:
        """获取估值数据"""
        # 估值数据每日更新一次，可以缓存
        cache_key = f"valuation_{code}_{date}"
        cached = self.cache_manager.get(cache_key)
        if cached is not None:
            return cached
        
        result = self.client.stock.get_valuation(code=code, date=date)
        
        # 缓存到当天结束
        self.cache_manager.set(cache_key, result, ttl=3600)
        
        return result
    
    def get_fundamentals(
        self,
        code: Union[str, List[str]],
        n: int = 1,
        freq: str = 'q',
        ref_date: Optional[str] = None
    ) -> Dict[str, List[Dict]]:
        """获取财务数据"""
        cache_key = f"fundamentals_{code}_{n}_{freq}_{ref_date}"
        cached = self.cache_manager.get(cache_key)
        if cached is not None:
            return cached
        
        result = self.client.stock.get_fundamentals_golden(
            code=code,
            n=n,
            freq=freq,
            ref_date=ref_date
        )
        
        # 财务数据不常变化，缓存时间长
        self.cache_manager.set(cache_key, result, ttl=86400)
        
        return result
    
    def is_suspended(
        self,
        code: Union[str, List[str]],
        date: Optional[str] = None
    ) -> List[Dict]:
        """判断停牌"""
        return self.client.stock.is_suspended(code=code, date=date)
    
    def get_trading_days(
        self,
        start: str,
        end: str
    ) -> List[str]:
        """获取交易日历"""
        return self.client.calendar.get_trading_days(
            start_date=start,
            end_date=end
        )
    
    def is_trading_day(self, date: str) -> bool:
        """判断是否为交易日"""
        result = self.client.calendar.is_trading_day(date=date)
        return result['is_trading_day']
```

---

### 5.2 缓存管理器（CacheManager）

#### 5.2.1 设计目标

- 减少API调用次数
- 提高数据访问速度
- 支持多种缓存策略（内存、文件、Redis）

#### 5.2.2 核心实现

```python
# data/cache/cache_manager.py

from typing import Any, Optional, Dict
from datetime import datetime, timedelta
import json
import os

class CacheManager:
    """缓存管理器"""
    
    def __init__(self, config: dict):
        self.config = config
        self.cache_type = config.get('type', 'memory')  # 'memory', 'file', 'redis'
        
        # 内存缓存
        self._memory_cache: Dict[str, Any] = {}
        self._cache_expire: Dict[str, datetime] = {}
        
        # 文件缓存目录
        if self.cache_type == 'file':
            self.cache_dir = config.get('cache_dir', '.cache')
            os.makedirs(self.cache_dir, exist_ok=True)
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        if self.cache_type == 'memory':
            return self._get_memory(key)
        elif self.cache_type == 'file':
            return self._get_file(key)
        else:
            raise NotImplementedError
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        """设置缓存"""
        if self.cache_type == 'memory':
            self._set_memory(key, value, ttl)
        elif self.cache_type == 'file':
            self._set_file(key, value, ttl)
        else:
            raise NotImplementedError
    
    def _get_memory(self, key: str) -> Optional[Any]:
        """从内存获取"""
        # 检查是否过期
        if key in self._cache_expire:
            if datetime.now() > self._cache_expire[key]:
                del self._memory_cache[key]
                del self._cache_expire[key]
                return None
        
        return self._memory_cache.get(key)
    
    def _set_memory(self, key: str, value: Any, ttl: Optional[int]):
        """写入内存"""
        self._memory_cache[key] = value
        
        if ttl:
            self._cache_expire[key] = datetime.now() + timedelta(seconds=ttl)
    
    def _get_file(self, key: str) -> Optional[Any]:
        """从文件获取"""
        file_path = os.path.join(self.cache_dir, f"{key}.json")
        
        if not os.path.exists(file_path):
            return None
        
        # 检查过期时间
        meta_path = file_path + '.meta'
        if os.path.exists(meta_path):
            with open(meta_path, 'r') as f:
                meta = json.load(f)
                expire_time = datetime.fromisoformat(meta['expire'])
                if datetime.now() > expire_time:
                    os.remove(file_path)
                    os.remove(meta_path)
                    return None
        
        # 读取数据
        with open(file_path, 'r') as f:
            return json.load(f)
    
    def _set_file(self, key: str, value: Any, ttl: Optional[int]):
        """写入文件"""
        file_path = os.path.join(self.cache_dir, f"{key}.json")
        
        # 写入数据
        with open(file_path, 'w') as f:
            json.dump(value, f)
        
        # 写入元数据
        if ttl:
            meta_path = file_path + '.meta'
            expire_time = datetime.now() + timedelta(seconds=ttl)
            with open(meta_path, 'w') as f:
                json.dump({
                    'expire': expire_time.isoformat()
                }, f)
    
    def get_tick(self, key: str) -> Optional[Any]:
        """获取Tick缓存（短期）"""
        return self.get(key)
    
    def set_tick(self, key: str, value: Any):
        """设置Tick缓存（5秒）"""
        self.set(key, value, ttl=5)
    
    def get_kline(self, key: str) -> Optional[Any]:
        """获取K线缓存"""
        return self.get(key)
    
    def set_kline(self, key: str, value: Any):
        """设置K线缓存（1小时）"""
        self.set(key, value, ttl=3600)
    
    def clear(self):
        """清空所有缓存"""
        if self.cache_type == 'memory':
            self._memory_cache.clear()
            self._cache_expire.clear()
        elif self.cache_type == 'file':
            for file in os.listdir(self.cache_dir):
                os.remove(os.path.join(self.cache_dir, file))
```

---

### 5.3 交易日历缓存（CalendarCache）

#### 5.3.1 设计目标

- 本地持久化交易日历
- 自动增量更新
- 快速查询交易日

#### 5.3.2 核心实现

```python
# data/cache/calendar_cache.py

import json
import os
from datetime import datetime, timedelta
from typing import List, Optional

class CalendarCache:
    """交易日历缓存"""
    
    def __init__(self, data_adapter, cache_file: str = '.cache/calendar.json'):
        self.data_adapter = data_adapter
        self.cache_file = cache_file
        
        # 加载本地缓存
        self.calendar_data = self._load_cache()
        
        # 自动更新
        self._auto_update()
    
    def _load_cache(self) -> dict:
        """加载缓存文件"""
        if os.path.exists(self.cache_file):
            with open(self.cache_file, 'r') as f:
                return json.load(f)
        else:
            return {
                'trading_days': [],
                'last_update': None
            }
    
    def _save_cache(self):
        """保存缓存文件"""
        os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
        with open(self.cache_file, 'w') as f:
            json.dump(self.calendar_data, f, indent=2)
    
    def _auto_update(self):
        """自动更新交易日历"""
        last_update = self.calendar_data.get('last_update')
        
        # 如果从未更新，或者距离上次更新超过1天，则更新
        should_update = (
            last_update is None or
            datetime.now() - datetime.fromisoformat(last_update) > timedelta(days=1)
        )
        
        if should_update:
            self._fetch_and_update()
    
    def _fetch_and_update(self):
        """从API获取并更新"""
        # 确定更新范围
        if self.calendar_data['trading_days']:
            # 从最后一个交易日开始更新
            last_day = max(self.calendar_data['trading_days'])
            start_date = last_day
        else:
            # 首次更新，获取2005年至今
            start_date = '2005-01-01'
        
        # 结束日期为明年年底（确保覆盖未来）
        end_date = f"{datetime.now().year + 1}-12-31"
        
        # 调用API
        try:
            new_days = self.data_adapter.get_trading_days(start_date, end_date)
            
            # 合并去重
            all_days = set(self.calendar_data['trading_days'] + new_days)
            self.calendar_data['trading_days'] = sorted(list(all_days))
            self.calendar_data['last_update'] = datetime.now().isoformat()
            
            # 保存
            self._save_cache()
            
        except Exception as e:
            print(f"Failed to update trading calendar: {e}")
    
    def is_trading_day(self, date: str) -> bool:
        """判断是否为交易日"""
        return date in self.calendar_data['trading_days']
    
    def get_trading_days(self, start: str, end: str) -> List[str]:
        """获取交易日列表"""
        return [
            day for day in self.calendar_data['trading_days']
            if start <= day <= end
        ]
    
    def get_previous_trading_day(self, date: str, n: int = 1) -> Optional[str]:
        """获取前N个交易日"""
        days = [d for d in self.calendar_data['trading_days'] if d < date]
        if len(days) >= n:
            return days[-n]
        return None
    
    def get_next_trading_day(self, date: str, n: int = 1) -> Optional[str]:
        """获取后N个交易日"""
        days = [d for d in self.calendar_data['trading_days'] if d > date]
        if len(days) >= n:
            return days[n - 1]
        return None
```

---

## 6. 交易撮合机制

### 6.1 撮合引擎设计

#### 6.1.1 核心逻辑

撮合引擎负责将用户的订单转化为成交，需要考虑：

1. **价格确定**：
   - 市价单：使用Tick的对手价（买入用ask1，卖出用bid1）
   - 限价单：使用限定价格
   - 无Tick数据时：使用当前K线的close或current_price

2. **滑点处理**：
   - 固定滑点：按配置的百分比或固定值
   - 动态滑点：基于订单量与Tick量的比例

3. **涨跌停限制**：
   - 获取涨跌停价格
   - 限价单价格超出涨跌停时失败
   - 市价单触及涨跌停时失败

4. **T+1/T+0规则**：
   - 股票T+1：当日买入不可卖出
   - ETF T+0：当日买入可卖出

#### 6.1.2 核心实现

```python
# trading/matching_engine.py

from datetime import datetime
from typing import Optional, Dict, Any
from .order import Order, OrderStatus, OrderSide
from .commission import CommissionCalculator
from .slippage import SlippageModel
from ..core.context import Context

class MatchingEngine:
    """撮合引擎"""
    
    def __init__(self, context: Context, config: dict):
        self.context = context
        self.config = config
        
        # 手续费计算器
        self.commission_calc = CommissionCalculator(config.get('commission', {}))
        
        # 滑点模型
        self.slippage_model = SlippageModel(config.get('slippage', {}))
    
    def match_orders(self, dt: datetime):
        """撮合当前所有未成交订单"""
        order_manager = self.context.order_manager
        
        # 获取所有OPEN状态的订单
        open_orders = order_manager.get_open_orders()
        
        for order in open_orders:
            self._try_match_order(order, dt)
    
    def _try_match_order(self, order: Order, dt: datetime):
        """尝试撮合单个订单"""
        # 检查停牌
        if self._is_suspended(order.symbol, dt):
            order.reject("标的停牌")
            return
        
        # 获取价格
        price = self._get_match_price(order, dt)
        if price is None:
            return  # 暂时无法撮合，等待下次
        
        # 检查涨跌停
        if not self._check_limit_price(order, price, dt):
            order.reject("触及涨跌停")
            return
        
        # 应用滑点
        slippage = self.slippage_model.calculate(order, price)
        final_price = price + slippage if order.side == OrderSide.BUY else price - slippage
        
        # 计算手续费
        commission = self.commission_calc.calculate(order, final_price)
        
        # 检查资金/持仓是否足够
        if not self._check_sufficiency(order, final_price, commission):
            order.reject("资金/持仓不足")
            return
        
        # 执行成交
        self._execute_order(order, final_price, commission, dt)
    
    def _get_match_price(self, order: Order, dt: datetime) -> Optional[float]:
        """获取撮合价格"""
        # 优先使用Tick数据
        tick = self._get_tick(order.symbol, dt)
        
        if tick:
            if order.order_type == 'market':
                # 市价单：买入用ask1，卖出用bid1
                if order.side == OrderSide.BUY:
                    return tick.get('ask1_price')
                else:
                    return tick.get('bid1_price')
            else:
                # 限价单：检查是否可以成交
                limit_price = order.limit_price
                if order.side == OrderSide.BUY:
                    # 买入：当卖一价低于等于限价时成交
                    if tick.get('ask1_price', float('inf')) <= limit_price:
                        return limit_price
                else:
                    # 卖出：当买一价高于等于限价时成交
                    if tick.get('bid1_price', 0) >= limit_price:
                        return limit_price
        
        # 无Tick数据，使用K线价格
        else:
            if self.context.mode == 'backtest':
                # 回测：使用当前bar的close
                kline = self._get_kline(order.symbol, dt)
                if kline:
                    close_price = kline[-1]['close']
                    
                    if order.order_type == 'market':
                        return close_price
                    else:
                        # 限价单简化处理：假设close价格可成交
                        limit_price = order.limit_price
                        if order.side == OrderSide.BUY:
                            if close_price <= limit_price:
                                return limit_price
                        else:
                            if close_price >= limit_price:
                                return limit_price
            else:
                # 实盘：使用虚拟K线的current_price
                vkline = self._get_vkline(order.symbol, dt)
                if vkline:
                    return vkline[0]['current_price']
        
        return None
    
    def _check_limit_price(self, order: Order, price: float, dt: datetime) -> bool:
        """检查涨跌停"""
        # 获取涨跌停价格
        limit_prices = self.context.data_adapter.get_limit_price(
            code=order.symbol,
            date=dt.strftime('%Y-%m-%d')
        )
        
        limit_data = limit_prices.get(order.symbol)
        if not limit_data:
            return True  # 无涨跌停数据，放行
        
        high_limit = limit_data['high_limit']
        low_limit = limit_data['low_limit']
        
        # 买入：不能超过涨停价
        if order.side == OrderSide.BUY:
            if price > high_limit:
                return False
        # 卖出：不能低于跌停价
        else:
            if price < low_limit:
                return False
        
        return True
    
    def _check_sufficiency(
        self,
        order: Order,
        price: float,
        commission: float
    ) -> bool:
        """检查资金/持仓是否足够"""
        portfolio = self.context.portfolio
        
        if order.side == OrderSide.BUY:
            # 买入：检查现金
            total_cost = price * order.amount + commission
            return portfolio.cash >= total_cost
        else:
            # 卖出：检查持仓
            position = self.context.position_manager.get_position(order.symbol)
            if not position:
                return False
            
            # 检查T+1规则
            if self._is_t_plus_1(order.symbol):
                # 股票T+1，检查可用数量
                return position.available_amount >= order.amount
            else:
                # T+0，检查总数量
                return position.total_amount >= order.amount
    
    def _execute_order(
        self,
        order: Order,
        price: float,
        commission: float,
        dt: datetime
    ):
        """执行订单成交"""
        order.fill(price, commission, dt)
        
        # 更新账户
        portfolio = self.context.portfolio
        position_manager = self.context.position_manager
        
        if order.side == OrderSide.BUY:
            # 买入：减少现金，增加持仓
            total_cost = price * order.amount + commission
            portfolio.cash -= total_cost
            
            position_manager.increase_position(
                order.symbol,
                order.amount,
                price,
                commission,
                dt
            )
        else:
            # 卖出：增加现金，减少持仓
            total_value = price * order.amount - commission
            portfolio.cash += total_value
            
            position_manager.decrease_position(
                order.symbol,
                order.amount,
                price,
                commission,
                dt
            )
        
        # 记录成交
        self.context.order_manager.add_filled_order(order)
    
    def settle(self):
        """每日收盘结算"""
        # 更新所有持仓市值
        position_manager = self.context.position_manager
        for position in position_manager.get_all_positions():
            # 获取收盘价
            close_price = self._get_close_price(position.symbol)
            if close_price:
                position.update_price(close_price)
        
        # 更新账户总值
        portfolio = self.context.portfolio
        total_value = portfolio.cash + sum(
            pos.market_value for pos in position_manager.get_all_positions()
        )
        portfolio.total_value = total_value
        
        # 更新持仓的可用数量（T+1处理）
        for position in position_manager.get_all_positions():
            if self._is_t_plus_1(position.symbol):
                # 今日买入的明日可卖
                position.available_amount = position.total_amount
    
    def _is_suspended(self, symbol: str, dt: datetime) -> bool:
        """判断是否停牌"""
        result = self.context.data_adapter.is_suspended(
            code=symbol,
            date=dt.strftime('%Y-%m-%d')
        )
        return result[0]['is_suspended'] if result else False
    
    def _is_t_plus_1(self, symbol: str) -> bool:
        """判断是否T+1交易"""
        # 简化：股票T+1，ETF T+0
        # 实际可通过查询标的类型判断
        return not symbol.startswith('5')  # ETF代码通常5开头
    
    def _get_tick(self, symbol: str, dt: datetime) -> Optional[Dict]:
        """获取Tick数据"""
        try:
            ticks = self.context.data_adapter.get_tick(code=symbol, dt=dt)
            return ticks.get(symbol)
        except:
            return None
    
    def _get_kline(self, symbol: str, dt: datetime) -> Optional[list]:
        """获取K线数据"""
        try:
            klines = self.context.data_adapter.get_kline(
                code=symbol,
                period='1d',
                end=dt.strftime('%Y-%m-%d'),
                count=1
            )
            return klines.get(symbol)
        except:
            return None
    
    def _get_vkline(self, symbol: str, dt: datetime) -> Optional[list]:
        """获取虚拟K线"""
        # 调用get_single_vkline接口
        # 需要在DataAdapter中实现
        pass
    
    def _get_close_price(self, symbol: str) -> Optional[float]:
        """获取当日收盘价"""
        dt = self.context.current_dt
        kline = self._get_kline(symbol, dt)
        if kline:
            return kline[-1]['close']
        return None
```

---

### 6.2 滑点模型

```python
# trading/slippage.py

from typing import Dict
from .order import Order

class SlippageModel:
    """滑点模型"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.type = config.get('type', 'fixed')  # 'fixed' 或 'volume_based'
        self.rate = config.get('rate', 0.001)    # 固定滑点率
    
    def calculate(self, order: Order, price: float) -> float:
        """计算滑点"""
        if self.type == 'fixed':
            return self._fixed_slippage(price)
        elif self.type == 'volume_based':
            return self._volume_based_slippage(order, price)
        else:
            return 0
    
    def _fixed_slippage(self, price: float) -> float:
        """固定滑点"""
        return price * self.rate
    
    def _volume_based_slippage(self, order: Order, price: float) -> float:
        """基于成交量的滑点"""
        # 简化实现：订单量越大，滑点越大
        base_slippage = price * self.rate
        volume_factor = min(order.amount / 10000, 2.0)  # 最多翻倍
        return base_slippage * volume_factor
```

---

### 6.3 手续费计算

```python
# trading/commission.py

from typing import Dict
from .order import Order, OrderSide

class CommissionCalculator:
    """手续费计算器"""
    
    def __init__(self, config: Dict):
        # 默认费率（股票）
        self.buy_commission = config.get('buy_commission', 0.0002)
        self.sell_commission = config.get('sell_commission', 0.0002)
        self.buy_tax = config.get('buy_tax', 0.0)
        self.sell_tax = config.get('sell_tax', 0.001)
        self.min_commission = config.get('min_commission', 5.0)
    
    def calculate(self, order: Order, price: float) -> float:
        """计算手续费"""
        total_value = price * order.amount
        
        if order.side == OrderSide.BUY:
            commission = total_value * self.buy_commission
            tax = total_value * self.buy_tax
        else:
            commission = total_value * self.sell_commission
            tax = total_value * self.sell_tax
        
        # 佣金不足最小值时，按最小值收取
        commission = max(commission, self.min_commission)
        
        return commission + tax
```

---

## 7. 时间与调度系统

### 7.1 时间推进策略

#### 7.1.1 回测模式

- **日频回测**：
  - 遍历交易日列表
  - 每日调用：before_trading → handle_bar → 撮合 → after_trading → 结算

- **分钟频回测**：
  - 遍历交易日
  - 每日遍历分钟时间点（09:30-11:30, 13:00-15:00）
  - 每分钟调用：handle_bar → 撮合

#### 7.1.2 实盘模式

- **实时驱动**：
  - 使用系统时钟
  - 判断当前时间点应执行的事件
  - 使用sleep精确控制调度频率

### 7.2 交易时段配置

```yaml
# configs/default.yaml

trading_hours:
  morning:
    start: "09:30:00"
    end: "11:30:00"
  afternoon:
    start: "13:00:00"
    end: "15:00:00"
  
  # 特殊事件时间点
  before_trading: "09:25:00"
  after_trading: "15:01:00"
```

---

## 8. 状态管理与持久化

### 8.1 设计目标

- 支持暂停/恢复运行
- 保存完整状态（账户、持仓、订单、缓存）
- 粒度：每日收盘后自动保存

### 8.2 核心实现

```python
# core/state_manager.py

import pickle
import os
from datetime import datetime
from typing import Optional
from .context import Context

class StateManager:
    """状态管理器"""
    
    def __init__(self, context: Context, save_dir: str = '.states'):
        self.context = context
        self.save_dir = save_dir
        os.makedirs(save_dir, exist_ok=True)
    
    def save_state(self, tag: Optional[str] = None):
        """保存当前状态"""
        # 生成文件名
        if tag is None:
            tag = self.context.current_dt.strftime('%Y%m%d')
        
        file_path = os.path.join(
            self.save_dir,
            f"{self.context.strategy_name}_{tag}.pkl"
        )
        
        # 收集状态
        state = {
            'context': self.context,
            'portfolio': self.context.portfolio,
            'positions': self.context.position_manager.get_all_positions(),
            'orders': self.context.order_manager.get_all_orders(),
            'user_data': self.context.user_data,
            'timestamp': datetime.now().isoformat()
        }
        
        # 序列化
        with open(file_path, 'wb') as f:
            pickle.dump(state, f)
        
        print(f"State saved to {file_path}")
    
    def load_state(self, file_path: str):
        """加载状态"""
        with open(file_path, 'rb') as f:
            state = pickle.load(f)
        
        # 恢复状态
        self.context = state['context']
        self.context.portfolio = state['portfolio']
        
        # 恢复持仓
        self.context.position_manager.restore_positions(state['positions'])
        
        # 恢复订单
        self.context.order_manager.restore_orders(state['orders'])
        
        # 恢复用户数据
        self.context.user_data = state['user_data']
        
        print(f"State loaded from {file_path}")
        print(f"Timestamp: {state['timestamp']}")
        
        return self.context
```

---

## 9. 回测与实盘模式

### 9.1 模式切换

#### 9.1.1 配置驱动

```yaml
# configs/backtest.yaml
mode: backtest
frequency: daily  # or minute
start_date: "2023-01-01"
end_date: "2023-12-31"
initial_cash: 1000000

data:
  type: api
  base_url: "http://localhost:8000/api/v1"
  api_key: "your_key"

matching:
  use_tick: true
  slippage:
    type: fixed
    rate: 0.001
  commission:
    buy_commission: 0.0002
    sell_commission: 0.0002
    sell_tax: 0.001
    min_commission: 5.0

cache:
  type: file
  cache_dir: .cache
```

```yaml
# configs/live.yaml
mode: live
frequency: minute
initial_cash: 1000000

data:
  type: api
  base_url: "http://your-api-server/api/v1"
  api_key: "your_live_key"

matching:
  use_tick: true
  slippage:
    type: fixed
    rate: 0.001

cache:
  type: memory
```

#### 9.1.2 使用示例

```python
from quant_framework import Engine
from my_strategy import MyStrategy

# 回测
engine_bt = Engine(config_path='configs/backtest.yaml')
engine_bt.run(
    MyStrategy,
    start_date='2023-01-01',
    end_date='2023-12-31'
)

# 实盘
engine_live = Engine(config_path='configs/live.yaml')
engine_live.run(MyStrategy)
```

---

### 9.2 数据获取差异

| 场景 | 数据接口 | 说明 |
|------|---------|------|
| 回测-历史K线 | get_kline | 获取已完成K线 |
| 回测-当前价格 | get_kline最后一根的close | 因果一致 |
| 实盘-实时价格 | get_single_vkline | 包含当前未完成K线 |
| 实盘-Tick行情 | get_tick | 实时五档 |

---

## 10. 可视化与报告

### 10.1 绩效分析

```python
# analysis/performance.py

import pandas as pd
from typing import List, Dict
from ..core.context import Context

class PerformanceAnalyzer:
    """绩效分析器"""
    
    def __init__(self, context: Context):
        self.context = context
    
    def get_returns(self) -> pd.Series:
        """获取收益率序列"""
        # 从账户历史记录生成
        pass
    
    def calculate_metrics(self) -> Dict:
        """计算绩效指标"""
        returns = self.get_returns()
        
        metrics = {
            'total_return': self._total_return(returns),
            'annual_return': self._annual_return(returns),
            'sharpe_ratio': self._sharpe_ratio(returns),
            'max_drawdown': self._max_drawdown(returns),
            'win_rate': self._win_rate(),
            'profit_factor': self._profit_factor()
        }
        
        return metrics
    
    def _total_return(self, returns: pd.Series) -> float:
        """总收益率"""
        return (1 + returns).prod() - 1
    
    def _annual_return(self, returns: pd.Series) -> float:
        """年化收益率"""
        days = len(returns)
        total_return = self._total_return(returns)
        return (1 + total_return) ** (252 / days) - 1
    
    def _sharpe_ratio(self, returns: pd.Series) -> float:
        """夏普比率"""
        return returns.mean() / returns.std() * (252 ** 0.5)
    
    def _max_drawdown(self, returns: pd.Series) -> float:
        """最大回撤"""
        cumulative = (1 + returns).cumprod()
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        return drawdown.min()
    
    def _win_rate(self) -> float:
        """胜率"""
        trades = self._get_closed_trades()
        if not trades:
            return 0
        wins = sum(1 for t in trades if t['pnl'] > 0)
        return wins / len(trades)
    
    def _profit_factor(self) -> float:
        """盈亏比"""
        trades = self._get_closed_trades()
        if not trades:
            return 0
        
        total_profit = sum(t['pnl'] for t in trades if t['pnl'] > 0)
        total_loss = abs(sum(t['pnl'] for t in trades if t['pnl'] < 0))
        
        if total_loss == 0:
            return float('inf')
        return total_profit / total_loss
    
    def _get_closed_trades(self) -> List[Dict]:
        """获取已平仓交易"""
        # 从订单历史中配对买卖单
        # 实现类似QFF的perf模块
        pass
```

---

### 10.2 可视化

```python
# analysis/visualizer.py

import matplotlib.pyplot as plt
import pandas as pd
from ..core.context import Context

class Visualizer:
    """可视化工具"""
    
    def __init__(self, context: Context):
        self.context = context
    
    def plot_equity_curve(self, save_path: str = None):
        """绘制权益曲线"""
        # 获取账户净值序列
        equity = self._get_equity_series()
        
        plt.figure(figsize=(12, 6))
        plt.plot(equity.index, equity.values, label='Strategy')
        
        # 如果有基准，绘制基准
        if self.context.config.get('benchmark'):
            benchmark = self._get_benchmark_series()
            plt.plot(benchmark.index, benchmark.values, label='Benchmark')
        
        plt.title('Equity Curve')
        plt.xlabel('Date')
        plt.ylabel('Portfolio Value')
        plt.legend()
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path)
        else:
            plt.show()
    
    def plot_drawdown(self, save_path: str = None):
        """绘制回撤曲线"""
        equity = self._get_equity_series()
        running_max = equity.expanding().max()
        drawdown = (equity - running_max) / running_max
        
        plt.figure(figsize=(12, 6))
        plt.fill_between(drawdown.index, drawdown.values, 0, alpha=0.3, color='red')
        plt.title('Drawdown')
        plt.xlabel('Date')
        plt.ylabel('Drawdown')
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path)
        else:
            plt.show()
    
    def _get_equity_series(self) -> pd.Series:
        """获取权益序列"""
        # 从账户历史记录生成
        pass
    
    def _get_benchmark_series(self) -> pd.Series:
        """获取基准序列"""
        # 从数据适配器获取基准指数
        pass
```

---

### 10.3 报告生成

```python
# analysis/report.py

from jinja2 import Template
from ..core.context import Context
from .performance import PerformanceAnalyzer
from .visualizer import Visualizer

class ReportGenerator:
    """报告生成器"""
    
    def __init__(self, context: Context):
        self.context = context
        self.analyzer = PerformanceAnalyzer(context)
        self.visualizer = Visualizer(context)
    
    def generate_html_report(self, output_path: str):
        """生成HTML报告"""
        # 计算指标
        metrics = self.analyzer.calculate_metrics()
        
        # 生成图表
        self.visualizer.plot_equity_curve(save_path='temp_equity.png')
        self.visualizer.plot_drawdown(save_path='temp_drawdown.png')
        
        # 渲染模板
        template = self._load_template()
        html = template.render(
            strategy_name=self.context.strategy_name,
            metrics=metrics,
            equity_chart='temp_equity.png',
            drawdown_chart='temp_drawdown.png'
        )
        
        # 保存
        with open(output_path, 'w') as f:
            f.write(html)
    
    def _load_template(self) -> Template:
        """加载HTML模板"""
        template_str = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>{{ strategy_name }} - 回测报告</title>
            <style>
                body { font-family: Arial, sans-serif; }
                .metric { margin: 10px 0; }
                .chart { margin: 20px 0; }
            </style>
        </head>
        <body>
            <h1>{{ strategy_name }} - 回测报告</h1>
            
            <h2>绩效指标</h2>
            {% for key, value in metrics.items() %}
            <div class="metric">
                <strong>{{ key }}:</strong> {{ "%.2f%%"|format(value * 100) }}
            </div>
            {% endfor %}
            
            <h2>权益曲线</h2>
            <img src="{{ equity_chart }}" class="chart">
            
            <h2>回撤曲线</h2>
            <img src="{{ drawdown_chart }}" class="chart">
        </body>
        </html>
        """
        return Template(template_str)
```

---

## 11. 扩展性设计

### 11.1 插件系统

```python
# plugins/base.py

from abc import ABC, abstractmethod
from ..core.context import Context

class Plugin(ABC):
    """插件基类"""
    
    def __init__(self, context: Context):
        self.context = context
    
    @abstractmethod
    def on_init(self):
        """初始化时调用"""
        pass
    
    def on_before_trading(self):
        """盘前调用"""
        pass
    
    def on_after_trading(self):
        """盘后调用"""
        pass
    
    def on_bar(self):
        """每个bar调用"""
        pass
```

示例插件：风险控制

```python
# plugins/risk_control.py

from .base import Plugin

class RiskControlPlugin(Plugin):
    """风险控制插件"""
    
    def __init__(self, context, max_position_ratio=0.3):
        super().__init__(context)
        self.max_position_ratio = max_position_ratio
    
    def on_init(self):
        print("Risk control plugin initialized")
    
    def on_bar(self):
        """检查仓位是否超限"""
        portfolio = self.context.portfolio
        
        for position in self.context.position_manager.get_all_positions():
            ratio = position.market_value / portfolio.total_value
            if ratio > self.max_position_ratio:
                # 触发风控：平仓部分持仓
                excess_amount = int((ratio - self.max_position_ratio) * portfolio.total_value / position.price)
                self.context.order_manager.submit_order(
                    position.symbol,
                    -excess_amount,
                    order_type='market'
                )
                print(f"Risk control: reduce position {position.symbol} by {excess_amount}")
```

---

## 12. 实施路线图

### 12.1 阶段一：核心框架（2周）

**目标**：搭建可运行的最小框架

- [ ] 实现Context、Engine、Scheduler
- [ ] 实现TimeManager和交易日历缓存
- [ ] 实现基础的数据适配器（API）
- [ ] 实现订单、持仓、账户模型
- [ ] 实现简单的撮合引擎（日频回测）
- [ ] 编写示例策略并测试

### 12.2 阶段二：撮合增强（1周）

**目标**：完善撮合机制

- [ ] 实现Tick级撮合
- [ ] 实现滑点模型
- [ ] 实现手续费计算
- [ ] 实现涨跌停检查
- [ ] 实现T+1/T+0规则
- [ ] 分钟频回测支持

### 12.3 阶段三：缓存与优化（1周）

**目标**：提升性能

- [ ] 实现CacheManager（内存、文件）
- [ ] 实现Tick、K线缓存策略
- [ ] 优化批量数据获取
- [ ] 实现数据预取（可选）

### 12.4 阶段四：状态管理（1周）

**目标**：支持暂停/恢复

- [ ] 实现StateManager
- [ ] 实现状态序列化/反序列化
- [ ] 实现自动保存点
- [ ] 测试恢复功能

### 12.5 阶段五：实盘支持（1周）

**目标**：支持实盘模式

- [ ] 实现实时调度逻辑
- [ ] 实现实盘数据获取
- [ ] 实现实盘撮合（模拟）
- [ ] 测试实盘模式运行

### 12.6 阶段六：分析与可视化（1周）

**目标**：完善分析工具

- [ ] 实现PerformanceAnalyzer
- [ ] 实现Visualizer
- [ ] 实现ReportGenerator
- [ ] 生成完整回测报告

### 12.7 阶段七：插件与扩展（1周）

**目标**：增强扩展性

- [ ] 实现插件基类
- [ ] 实现示例插件（风控、通知）
- [ ] 实现策略API增强
- [ ] 文档完善

### 12.8 阶段八：Web界面（可选，2周）

**目标**：提供在线平台

- [ ] 实现Flask/FastAPI后端
- [ ] 实现策略编辑器
- [ ] 实现回测任务管理
- [ ] 实现可视化图表展示
- [ ] 实现用户系统（可选）

---

## 13. 配置示例

### 13.1 完整配置文件

```yaml
# configs/default.yaml

# 运行模式
mode: backtest  # backtest | live

# 策略基本信息
strategy_name: "MyStrategy"
frequency: daily  # daily | minute

# 回测时间范围
start_date: "2023-01-01"
end_date: "2023-12-31"

# 初始资金
initial_cash: 1000000

# 数据源配置
data:
  type: api  # api | local
  base_url: "http://localhost:8000/api/v1"
  api_key: "your_api_key"
  timeout: 30
  max_retries: 3

# 缓存配置
cache:
  type: file  # memory | file | redis
  cache_dir: .cache
  ttl:
    tick: 5
    kline: 3600
    stock_list: 86400

# 撮合配置
matching:
  use_tick: true  # 是否使用Tick数据撮合
  
  slippage:
    type: fixed  # fixed | volume_based
    rate: 0.001
  
  commission:
    buy_commission: 0.0002
    sell_commission: 0.0002
    buy_tax: 0.0
    sell_tax: 0.001
    min_commission: 5.0

# 交易时段
trading_hours:
  morning:
    start: "09:30:00"
    end: "11:30:00"
  afternoon:
    start: "13:00:00"
    end: "15:00:00"
  before_trading: "09:25:00"
  after_trading: "15:01:00"

# 基准
benchmark: "000300.XSHG"  # 沪深300

# 状态保存
state:
  auto_save: true
  save_dir: .states
  save_frequency: daily  # 每日收盘保存

# 日志
logging:
  level: INFO
  file: logs/backtest.log

# 报告
report:
  output_dir: reports
  auto_generate: true
```

---

## 14. 策略示例

### 14.1 简单均线策略

```python
# examples/simple_ma.py

from quant_framework import Engine
from quant_framework.strategy import Strategy

class SimpleMAStrategy(Strategy):
    """简单双均线策略"""
    
    def initialize(self, context):
        """初始化"""
        context.set('ma_short', 5)
        context.set('ma_long', 20)
        context.set('symbol', '000001')
    
    def handle_bar(self, context, data):
        """每个bar执行"""
        symbol = context.get('symbol')
        
        # 获取历史数据
        prices = data.history(symbol, 'close', context.get('ma_long') + 1)
        
        # 计算均线
        ma_short = prices[-context.get('ma_short'):].mean()
        ma_long = prices.mean()
        
        # 获取当前持仓
        position = context.position_manager.get_position(symbol)
        
        # 交易逻辑
        if ma_short > ma_long:
            # 金叉：买入
            if position is None or position.total_amount == 0:
                # 计算买入数量（使用50%资金）
                cash = context.portfolio.cash
                price = data.current(symbol, 'price')
                amount = int(cash * 0.5 / price / 100) * 100
                
                if amount > 0:
                    context.order_manager.submit_order(symbol, amount)
        
        elif ma_short < ma_long:
            # 死叉：卖出
            if position and position.total_amount > 0:
                context.order_manager.submit_order(symbol, -position.total_amount)

if __name__ == '__main__':
    engine = Engine(config_path='configs/backtest.yaml')
    engine.run(
        SimpleMAStrategy,
        start_date='2023-01-01',
        end_date='2023-12-31'
    )
```

---

## 15. 总结

本文档详细设计了一个基于Stock API的量化交易框架，核心特点包括：

1. **数据实时获取**：无需预下载，基于API按需获取
2. **事件驱动架构**：清晰的生命周期钩子
3. **灵活撮合机制**：支持Tick五档、涨跌停、滑点、T+1等
4. **智能缓存策略**：最小化API调用
5. **回测/实盘统一**：同一套代码无缝切换
6. **状态可持久化**：支持暂停/恢复
7. **高度可扩展**：插件化架构

本框架参考了Zipline、Backtrader、QFF等优秀框架的设计思想，但在数据获取、撮合机制、缓存策略等方面进行了创新，更适合基于API的实时数据场景。

建议按照实施路线图逐步开发，优先实现核心功能，再逐步完善高级特性。初期可以从日频回测开始，验证框架可行性后再扩展到分钟频和实盘。