好的，我们来一次最详尽、最清晰的重构。我完全理解您希望不仅看到代码，更要明白每一行修改背后的深层逻辑和设计哲学。

我将严格遵循我们最后达成的“**隔离、警告、赋能**”这一核心设计理念，对您提供的最新代码进行一次完整的、带有详尽注释的升级。

---

### **第一部分：最终方案的详细设计思路与修改说明 (重述)**

在开始看代码之前，让我们再次明确我们的目标和实现路径。这套方案将是最终的、最稳健的版本。

#### **核心哲学：框架与策略的权责分离**

1.  **框架的责任 (我们的代码)**：
    *   **永不崩溃**：无论策略代码如何出错（`KeyError`, `NoneType` 错误, 死循环），框架本身必须存活。
    *   **时间权威**：框架必须始终与真实世界的时间保持同步。如果发生时间断裂（因暂停或阻塞），框架必须有能力自我修复。
    *   **提供上下文**：框架必须清晰地告诉策略代码，它当前所处的环境是什么（例如，现在是盘前还是盘中？今天策略是否已经出过错了？）。

2.  **策略的责任 (用户的代码)**：
    *   **逻辑自洽**：策略需要自己处理因“错过”某些事件而导致的状态缺失问题。
    *   **环境适应**：策略应该利用框架提供的上下文信息，编写出能够适应异常情况（如盘中启动）的健壮代码。

#### **实现这一哲学的四大支柱**

1.  **异常防火墙 (在 `LifecycleManager` 中实现)**
    *   **做什么**：用一个“万能”的 `try...except Exception` 语句块包裹所有对用户策略代码的调用。
    *   **为什么**：这是保证框架永不崩溃的基石。当用户的 `handle_bar` 因为缺少 `before_trading` 设置的变量而报错时，我们不再让整个程序停止，而是捕获这个错误，详细记录下来，然后让框架的主循环继续运行。程序不会退出，第二天依然能正常开始。

2.  **阻塞看门狗 (在 `LifecycleManager` 中实现)**
    *   **做什么**：在调用用户代码前后计时，如果超时，就设置一个全局的“请求同步”标志 (`context.resync_requested`)。
    *   **为什么**：将检测逻辑放在唯一的用户代码入口，可以确保**无死角监控**。任何钩子函数里的阻塞都会被发现。它只负责“举旗”，不负责处理，职责单一。

3.  **响应式调度器 (在 `Scheduler` 中实现)**
    *   **做什么**：`Scheduler` 的主循环在调用任何一个用户钩子后，都会立即检查“请求同步”标志。如果发现标志，它会命令 `Engine` 执行时间同步，然后重置自己的内部状态，从新的时间点重新开始。
    *   **为什么**：这是对“时间断裂”的快速响应。一旦发现阻塞导致的时间偏差，`Scheduler` 会立即放弃旧的时间线，基于 `Engine` 修复后的新时间线重新工作，确保不会遗漏任何重要的（如日结）事件。

4.  **丰富的上下文 (在 `Context` 和 `Scheduler` 中实现)**
    *   **做什么**：
        *   在 `Context` 中增加 `market_phase` (市场阶段) 和 `strategy_error_today` (今日策略是否已出错) 两个状态。
        *   `Scheduler` 负责根据真实时间实时更新 `market_phase`。
        *   `LifecycleManager` 在捕获到异常时负责设置 `strategy_error_today`。
        *   `IntegratedServer` 将这两个状态传递给前端UI。
    *   **为什么**：这是“赋能用户”的核心。用户现在可以在策略里写出这样的代码：`if context.market_phase != 'BEFORE_TRADING': ...` 来保护自己的时间敏感操作。同时，前端UI也能明确地告诉用户：“你的策略今天出错了，快去日志里看看吧！”，极大地提升了可用性。

---

### **第二部分：带详细注释的完整代码**

以下是所有被修改文件的最终版本，包含了详尽的注释。

#### **1. `qtrader/core/context.py` (已修改)**
```python
# qtrader/core/context.py

from datetime import datetime
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
import logging

# 避免循环导入的类型提示
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ..trading.account import Portfolio
    from ..trading.order_manager import OrderManager
    from ..trading.position_manager import PositionManager
    from ..benchmark.benchmark_manager import BenchmarkManager
    from ..analysis.integrated_server import IntegratedServer
    from ..data.interface import AbstractDataProvider
    from .engine import Engine

@dataclass
class Context:
    """
    全局上下文对象 (V6)
    这是框架中最核心的对象，是所有组件共享信息和状态的“中央总线”。
    """

    # ========== 基础运行信息 ==========
    mode: str = 'backtest'
    strategy_name: str = 'UnnamedStrategy'
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    current_dt: Optional[datetime] = None
    
    # [NEW] 市场阶段状态，由 Scheduler 负责更新。
    # 为什么？这是“赋能用户”的关键。它为策略代码提供了一个清晰、可靠的判断依据，
    # 知道当前真实的市场阶段，从而可以编写出能应对盘中启动等异常情况的健壮逻辑。
    market_phase: str = 'CLOSED' # 可能的值: BEFORE_TRADING, TRADING, AFTER_TRADING, SETTLEMENT, CLOSED

    # ========== 频率设置 ==========
    frequency: str = 'daily'
    frequency_options: Dict[str, Any] = field(default_factory=dict)

    # ========== 核心管理器 ==========
    portfolio: Optional['Portfolio'] = None
    order_manager: Optional['OrderManager'] = None
    position_manager: Optional['PositionManager'] = None
    benchmark_manager: Optional['BenchmarkManager'] = None
    # [NEW] 增加对主引擎的引用。
    # 为什么？这允许 Scheduler 等低层组件通过 context.engine 向上回调 Engine 的核心方法（如时间同步），
    # 而无需在初始化时层层传递 Engine 实例，实现了某种程度的“依赖注入”，使代码更清晰。
    engine: Optional['Engine'] = None

    # ========== 配置信息 ==========
    config: Dict[str, Any] = field(default_factory=dict)

    # ========== 用户自定义数据存储 ==========
    user_data: Dict[str, Any] = field(default_factory=dict)

    # ========== 运行状态 ==========
    is_running: bool = False
    is_paused: bool = False
    start_paused: bool = False # 新增：用于处理“启动即暂停”的功能
    was_interrupted: bool = False
    pause_requested: bool = False
    stop_requested: bool = False

    # [NEW] 时间同步请求标志位。
    # 这是“检测器-响应器”模型的核心通信机制。
    # LifecycleManager (检测器) 在发现阻塞后，会将此标志设为 True。
    # Scheduler (响应器) 会在循环中持续检查此标志。
    resync_requested: bool = False
    
    # [NEW] 当日策略是否发生错误的标志位。
    # LifecycleManager 在捕获异常时设置它，Scheduler 在新的一天开始时重置它。
    # IntegratedServer 读取它并传递给前端，用于UI告警。
    strategy_error_today: bool = False

    # ========== 可视化服务 ==========
    visualization_server: Optional['IntegratedServer'] = None

    # ========== 日志 ==========
    logger: Optional[logging.Logger] = None
    
    # ========== 数据提供者 ==========
    data_provider: Optional['AbstractDataProvider'] = None

    # ========== 每日静态信息缓存 ==========
    symbol_info_cache: Dict[str, Any] = field(default_factory=dict) 

    # ========== 盘中收益曲线 ==========
    intraday_equity_history: List[Dict[str, Any]] = field(default_factory=list)
    intraday_benchmark_history: List[Dict[str, Any]] = field(default_factory=list)
    
    # ========== 回测日志 ==========
    log_buffer: List[Dict[str, Any]] = field(default_factory=list)
    log_buffer_limit: int = 1000

    # ... (get/set 方法保持不变) ...
```

#### **2. `qtrader/core/lifecycle.py` (已修改)**
```python
# qtrader/core/lifecycle.py

from typing import Optional
import time
import traceback # 引入 traceback 模块以打印详细的错误信息
from qtrader.core.context import Context
from qtrader.strategy.base import Strategy

class LifecycleManager:
    """
    生命周期管理器 (V6 - 带有异常隔离防火墙和阻塞看门狗)
    
    角色定位：检测器 (The Detector) & 安全执行器
    - 安全执行器：确保用户代码的异常不会搞垮整个框架。
    - 检测器：监控用户代码的执行耗时，并在超时后发出警报。
    """

    def __init__(self, context: Context):
        self.context = context
        self.strategy: Optional[Strategy] = None
        # [NEW] 从配置中读取阻塞阈值。
        self.block_threshold_seconds = self.context.config.get('engine', {}).get('block_threshold_seconds', 5)

    def register_strategy(self, strategy: Strategy):
        self.strategy = strategy

    def _call_hook(self, hook_name: str):
        """
        [MODIFIED] 通用钩子调用函数，内置两大核心安全机制。
        这是整个健壮性设计的关键所在。
        """
        if self.strategy is None:
            self.context.logger.error("错误: 策略对象未注册。")
            return

        hook_method = getattr(self.strategy, hook_name, None)
        if callable(hook_method):
            
            is_simulation = self.context.mode == 'simulation'
            time_before = time.monotonic() if is_simulation else 0
            
            # --- 机制一: 异常隔离防火墙 ---
            try:
                self.context.logger.debug(f"调用策略钩子: {hook_name}()")
                hook_method(self.context)
            
            # 捕获所有源自用户代码的异常
            except Exception as e:
                # [MODIFIED] 不再停止引擎！这是保证框架鲁棒性的关键。
                
                # 记录详细的错误日志，包括完整的 traceback，方便用户定位问题。
                error_trace = traceback.format_exc()
                self.context.logger.error(f"执行策略钩子 {hook_name}() 时发生严重错误: {e}")
                self.context.logger.error(f"详细错误追踪:\n{error_trace}")
                
                # [NEW] 设置当日错误标志，用于UI告警。
                self.context.strategy_error_today = True
                
                # 即使发生错误，也让框架继续运行。
                return

            # --- 机制二: 阻塞看门狗 ---
            if is_simulation:
                time_after = time.monotonic()
                duration = time_after - time_before
                
                # 如果执行时间超过了我们设定的阈值
                if duration > self.block_threshold_seconds:
                    self.context.logger.warning(f"检测到策略钩子 '{hook_name}' 严重阻塞 {duration:.2f} 秒！")
                    self.context.logger.warning("已触发时间同步请求，系统将自动校准...")
                    
                    # [NEW] 举起“信号旗”，通知 Scheduler 需要进行时间同步。
                    self.context.resync_requested = True
    
    # 其他 call_... 方法保持不变，它们自动继承了 _call_hook 的安全特性
    def call_initialize(self):
        self._call_hook('initialize')

    def call_before_trading(self):
        self._call_hook('before_trading')

    def call_handle_bar(self):
        self._call_hook('handle_bar')

    def call_after_trading(self):
        self._call_hook('after_trading')

    def call_broker_settle(self):
        self._call_hook('broker_settle')

    def call_on_end(self):
        self._call_hook('on_end')
```

#### **3. `qtrader/runner/backtest_runner.py` (已修改)**
这个文件从命令行工具演变为更灵活的程序化接口。

```python
# qtrader/runner/backtest_runner.py

from qtrader.core.engine import Engine
from typing import Optional
import sys
import traceback

class BacktestRunner:
    """
    运行启动器 (V5) - 程序化接口

    提供以静态方法调用的方式，来启动全新、恢复或分叉的运行。
    这比命令行更适合集成到其他Python脚本或应用中。
    """

    @staticmethod
    def run_new(
        config_path: str, 
        strategy_path: str, 
        data_provider_path: str,
        start_paused: bool = False  
    ):
        """
        启动一个全新的运行（回测或模拟盘）。

        Args:
            config_path (str): 配置文件路径。
            strategy_path (str): 策略文件路径。
            data_provider_path (str): 数据提供者文件路径。
            start_paused (bool): 如果为 True，运行将在启动后立即暂停，等待UI操作。
        """
        print("=" * 60)
        print("QTrader - 启动全新运行 (程序化调用)")
        print("=" * 60)
        print(f"配置文件: {config_path}")
        print(f"策略文件: {strategy_path}")
        print(f"数据提供者: {data_provider_path}")
        if start_paused:
            print("启动模式: 启动后立即暂停")
        print("=" * 60)
        try:
            engine = Engine(config_path)
            engine.run(strategy_path, data_provider_path, start_paused=start_paused)
        except Exception as e:
            print(f"\n运行失败: {e}", file=sys.stderr)
            traceback.print_exc()

    @staticmethod
    def run_resume(
        state_file: str, 
        config_path: Optional[str] = None, 
        data_provider_path: Optional[str] = None, 
        start_paused: bool = False
    ):
        """
        从状态文件恢复一个中断的运行。

        Args:
            state_file (str): 状态文件 (.pkl) 的路径。
            config_path (Optional[str]): （可选）新的配置文件路径，用于覆盖状态中的配置。
            data_provider_path (Optional[str]): （可选）新的数据提供者路径。
            start_paused (bool): （可选）如果为 True，运行将在恢复后立即暂停。
        """
        print("=" * 60)
        print("QTrader - 恢复中断的运行 (程序化调用)")
        print("=" * 60)
        print(f"状态文件: {state_file}")
        if config_path: print(f"覆盖配置文件: {config_path}")
        if data_provider_path: print(f"覆盖数据提供者: {data_provider_path}")
        if start_paused: print("启动模式: 恢复后立即暂停")
        print("=" * 60)
        try:
            engine = Engine.load_from_state(state_file, config_path)
            engine.resume(data_provider_path, start_paused=start_paused)
        except Exception as e:
            print(f"\n运行失败: {e}", file=sys.stderr)
            traceback.print_exc()

    @staticmethod
    def run_fork(
        state_file: str, 
        strategy_path: str, 
        config_path: Optional[str] = None, 
        data_provider_path: Optional[str] = None, 
        no_reinit: bool = False,
        start_paused: bool = False
    ):
        """
        从一个历史状态文件分叉出一个新的运行。

        Args:
            state_file (str): 用于分叉的状态文件 (.pkl) 的路径。
            strategy_path (str): 新的策略文件路径。
            config_path (Optional[str]): （可选）新的配置文件路径。
            data_provider_path (Optional[str]): （可选）新的数据提供者路径。
            no_reinit (bool): （可选）如果为 True，则不重新初始化策略（高级功能）。
            start_paused (bool): （可选）如果为 True，运行将在分叉后立即暂停。
        """
        reinitialize = not no_reinit
        print("=" * 60)
        print("QTrader - 从快照分叉运行 (程序化调用)")
        print("=" * 60)
        print(f"状态文件: {state_file}")
        print(f"新策略文件: {strategy_path}")
        if config_path: print(f"覆盖配置文件: {config_path}")
        if data_provider_path: print(f"新数据提供者: {data_provider_path}")
        print(f"重新初始化策略: {'是' if reinitialize else '否 (高级模式)'}")
        if start_paused: print("启动模式: 分叉后立即暂停")
        print("=" * 60)
        
        try:
            engine = Engine.load_from_state(state_file, config_path)
            engine.run_from_snapshot(
                strategy=strategy_path,
                data_provider=data_provider_path,
                reinitialize=reinitialize,
                start_paused=start_paused
            )
        except Exception as e:
            print(f"\n运行失败: {e}", file=sys.stderr)
            traceback.print_exc()
```

#### **4. `qtrader/core/engine.py` (已修改)**
这是修改的核心文件之一，包含了统一的模拟盘入口和时间同步执行器。

```python
# qtrader/core/engine.py

import signal
import webbrowser
import importlib.util
import sys
from pathlib import Path
import time
from datetime import datetime, timedelta, time as time_obj, date
from typing import Optional, Type, Dict, Any

from ..core.config import load_config
from ..core.context import Context
from ..core.workspace_manager import WorkspaceManager
from ..core.time_manager import TimeManager
from ..core.scheduler import Scheduler
from ..core.lifecycle import LifecycleManager
from ..strategy.base import Strategy
from ..data.interface import AbstractDataProvider
from ..trading.account import Portfolio
from ..trading.order_manager import OrderManager
from ..trading.position_manager import PositionManager
from ..trading.matching_engine import MatchingEngine
from ..benchmark.benchmark_manager import BenchmarkManager
from ..utils.logger import setup_logger
from ..utils.serializer import StateSerializer
from ..analysis.integrated_server import IntegratedServer
from ..trading.order import OrderStatus

class Engine:
    """
    QTrader主引擎 (V6 - 哲理升级)
    
    角色定位：执行器 (The Executor) & 总协调官
    - 总协调官：负责启动、恢复、分叉等顶层流程，并组装所有核心组件。
    - 执行器：负责执行最核心的“时间同步”操作。
    """
    
    # ... (__init__, _validate_config, load_from_state 保持不变) ...

    # --- 统一的启动入口 ---
    
    def run(self, strategy: str, data_provider: str, start_paused: bool = False):
        """[MODIFIED] 启动全新运行，根据模式分发到不同流程"""
        mode = self.config.get('engine', {}).get('mode', 'backtest')
        if mode == 'simulation':
            self._run_simulation_unified(strategy, data_provider, is_resume=False, start_paused=start_paused)
        else:
            self._run_backtest_new(strategy, data_provider, start_paused=start_paused)
    
    def resume(self, data_provider_path: str = None, start_paused: bool = False):
        """[MODIFIED] 恢复中断的运行，根据模式分发到不同流程"""
        if not hasattr(self, '_state_to_restore'):
            raise RuntimeError("无法恢复：未从状态文件加载引擎。")
        
        mode = self._state_to_restore['context']['mode']
        if mode == 'simulation':
            self._run_simulation_unified(None, data_provider_path, is_resume=True, start_paused=start_paused)
        else:
            self._run_backtest_resume(data_provider_path, start_paused=start_paused)

    # --- 回测专用方法 ---

    def _run_backtest_new(self, strategy: str, data_provider: str, start_paused: bool = False):
        """[REFACTORED] 原有的全新回测逻辑"""
        # ... (此处是原来 run 方法中所有回测相关的代码，最后一行调用 self._execute_main_loop()) ...

    def _run_backtest_resume(self, data_provider: str = None, start_paused: bool = False):
        """[REFACTORED] 原有的恢复回测逻辑"""
        # ... (此处是原来 resume 方法中所有回测相关的代码，最后一行调用 self._execute_main_loop()) ...

    # --- 模拟盘统一处理核心 ---
    
    def _run_simulation_unified(self, strategy_path: Optional[str], data_provider_path: Optional[str], is_resume: bool, start_paused: bool = False):
        """
        [NEW] 统一处理全新和恢复的模拟盘启动流程。
        """
        # --- 步骤1: 初始化和加载状态 ---
        if is_resume:
            self.temp_logger.info("=" * 60); self.temp_logger.info("QTrader - 恢复模拟交易"); self.temp_logger.info("=" * 60)
            state = self._state_to_restore
            state_path = Path(self._state_file_path)
            workspace_dir = state_path.parent

            self.context = Context(config=self.config)
            log_config = self.config.get('logging', {}); log_config['file'] = str(workspace_dir / "simulation.log")
            self.context.logger = setup_logger(log_config, self.context)
            self._restore_components_from_state(state)
            
            strategy_path = str(workspace_dir / "snapshot_code.py")
            if data_provider_path is None: data_provider_path = str(workspace_dir / "snapshot_data_provider.py")
            
            self.workspace_manager = WorkspaceManager(strategy_path, data_provider_path, self.config, self.context.logger, workspace_dir_override=str(workspace_dir))
        else: 
            self.temp_logger.info("=" * 60); self.temp_logger.info("QTrader - 启动全新模拟交易"); self.temp_logger.info("=" * 60)
            self.workspace_manager = WorkspaceManager(strategy_path, data_provider_path, self.config, self.temp_logger)
            self.context = Context(config=self.config); self.context.mode = 'simulation'
            log_config = self.config.get('logging', {}); log_config['file'] = str(self.workspace_manager.log_file)
            self.context.logger = setup_logger(log_config, self.context)
            self.workspace_manager.logger = self.context.logger
            strategy_class = self._load_strategy_class(strategy_path); self._initialize_components(strategy_class)
        
        self.context.engine = self
        data_provider_instance = self._load_data_provider(data_provider_path)
        self.context.data_provider = data_provider_instance
        
        # --- 步骤2: 执行核心的时间同步流程 ---
        self._synchronize_to_realtime(is_new_run=(not is_resume))

        # --- 步骤3: 启动运行 ---
        self.context.is_running = True
        if start_paused: self.context.start_paused = True # 设置启动即暂停标志
        self._start_server_if_enabled()
        self._register_signal_handlers()
        self._execute_main_loop(skip_initialize=True)

    def _synchronize_to_realtime(self, is_new_run: bool = False):
        """
        [NEW & CORE] 核心方法：状态快进与时间同步。
        """
        self.context.logger.info("开始执行时间同步程序...")
        
        time_manager = TimeManager(self.context)
        lifecycle_manager = LifecycleManager(self.context)
        strategy_class = self._load_strategy_class(str(self.workspace_manager.workspace_dir / "snapshot_code.py"))
        strategy_instance = strategy_class(); lifecycle_manager.register_strategy(strategy_instance)
        
        if is_new_run:
            self.context.current_dt = datetime.now()
            self.context.logger.info("全新模拟，调用 initialize()..."); lifecycle_manager.call_initialize()
            last_sync_dt = self.context.current_dt
        else:
            last_sync_dt = self.context.current_dt
        
        now = datetime.now()
        self.context.logger.info(f"上次同步时间: {last_sync_dt.strftime('%Y-%m-%d %H:%M:%S')}")
        self.context.logger.info(f"目标同步时间: {now.strftime('%Y-%m-%d %H:%M:%S')}")

        missed_trading_days = time_manager.get_trading_days((last_sync_dt + timedelta(days=1)).strftime('%Y-%m-%d'), (now - timedelta(days=1)).strftime('%Y-%m-%d'))

        if not is_new_run:
            self.context.logger.info("清理瞬时状态: 将所有 OPEN 订单置为 EXPIRED...");
            for order in self.context.order_manager.get_open_orders(): order.expire()
            self.context.order_manager.clear_today_orders()
        
        self.context.intraday_equity_history.clear(); self.context.intraday_benchmark_history.clear()
        
        if missed_trading_days:
            self.context.logger.info(f"检测到 {len(missed_trading_days)} 个错过的交易日，开始状态快进...")
            matching_engine = MatchingEngine(self.context, self.config.get('matching', {}))
            broker_settle_time_str = self.config.get('lifecycle', {}).get('hooks', {}).get('broker_settle', '15:30:00')
            
            for day_str in missed_trading_days:
                self.context.logger.debug(f"模拟结算日: {day_str}")
                settle_dt = datetime.strptime(f"{day_str} {broker_settle_time_str}", "%Y-%m-%d %H:%M:%S")
                self.context.current_dt = settle_dt
                
                # [关键] 调用框架自身的结算逻辑，这些是安全的，不依赖用户代码的实时性
                matching_engine.settle(); self.context.benchmark_manager.update_daily()
                
                # [关键] 调用用户自定义的盘后和结算钩子，因为这些钩子针对的是“已过去”的一天，
                # 通常是安全的（例如，进行当日复盘统计）。
                lifecycle_manager.call_after_trading(); lifecycle_manager.call_broker_settle()
        
        self.context.current_dt = now
        self.context.logger.info(f"状态已同步至当前时间: {now.strftime('%Y-%m-%d %H:%M:%S')}")
        
        hooks = self.config.get('lifecycle', {}).get('hooks', {}); before_trading_time = datetime.strptime(hooks.get('before_trading', '09:15:00'), '%H:%M:%S').time(); after_trading_time = datetime.strptime(hooks.get('after_trading', '15:05:00'), '%H:%M:%S').time()

        if time_manager.is_trading_day(now):
            if now.time() < before_trading_time:
                self.context.market_phase = 'BEFORE_TRADING'
            elif now.time() < after_trading_time:
                self.context.market_phase = 'TRADING'
                self.context.logger.warning(f"盘中恢复/启动！将在当前时间({now.time()})补发'before_trading'事件。请确保您的策略代码能处理这种情况！")
                lifecycle_manager.call_before_trading()
            else:
                self.context.market_phase = 'AFTER_TRADING'
                self.context.logger.warning(f"盘后恢复/启动！将在当前时间({now.time()})补发'before_trading'和'after_trading'事件。")
                lifecycle_manager.call_before_trading(); lifecycle_manager.call_after_trading()
        else:
             self.context.market_phase = 'CLOSED'
             
        matching_engine = MatchingEngine(self.context, self.config.get('matching', {}))
        self.scheduler = Scheduler(self.context, time_manager, matching_engine, lifecycle_manager)

    def _execute_main_loop(self, skip_initialize=False):
        """[MODIFIED] 统一的主循环启动器"""
        self.context.is_running = True
        try:
            self.scheduler.run(skip_initialize=skip_initialize)
        except Exception as e:
            self.context.logger.error(f"运行时发生异常: {e}", exc_info=True)
            self.context.was_interrupted = True
        finally:
            self.context.logger.info("执行最终收尾程序..."); self._finalize()

    def _restore_components_from_state(self, state: Dict[str, Any]):
        """[NEW] 从 state 字典中恢复所有组件的状态"""
        # ... (此处是原来 resume 和 fork 方法中所有用于恢复的代码块) ...

    # ... (其他私有方法如 _load_strategy_class, _initialize_components, _finalize 等保持不变) ...

```

#### **5. `qtrader/core/scheduler.py` (已修改)**
```python
# qtrader/core/scheduler.py

import time as time_module
from datetime import datetime, time, timedelta, date
from typing import List
from qtrader.core.context import Context
from qtrader.core.time_manager import TimeManager
from qtrader.core.lifecycle import LifecycleManager
from qtrader.trading.matching_engine import MatchingEngine

class Scheduler:
    """
    事件调度器 (V6 - 带有市场阶段管理和响应式自愈)
    
    角色定位：响应器 (The Responder) & 状态机
    - 状态机：管理实时循环中的市场阶段和每日事件标志。
    - 响应器：响应“时间同步”请求，命令 Engine 进行自愈。
    """

    # ... (__init__ 保持不变) ...

    def _enter_pause_loop(self) -> bool:
        """进入暂停等待循环"""
        # ... (此方法保持不变) ...

    def _check_and_handle_requests(self) -> bool:
        """检查暂停/停止请求"""
        # ... (此方法保持不变) ...

    def run(self, skip_initialize: bool = False):
        """
        [MODIFIED] 主运行循环，增加了“启动即暂停”的处理逻辑。
        """
        if not skip_initialize:
            self.lifecycle_manager.call_initialize()
            if self.context.mode == 'simulation' and self.context.resync_requested:
                self.context.engine._synchronize_to_realtime(); self.context.resync_requested = False

        # [NEW] 处理“启动即暂停”的逻辑
        if self.context.start_paused:
            self.context.logger.info("运行以暂停状态启动。请在监控页面点击 '恢复' 继续。")
            self.context.is_paused = True
            self.context.start_paused = False
            self._maybe_update_server()
            if not self._enter_pause_loop():
                return

        if self.context.mode == 'backtest':
            self._run_backtest(skip_initialize)
        else:
            self._run_simulation()

    def _run_backtest(self, skip_initialize: bool = False):
        """回测模式运行循环"""
        # ... (此方法保持不变) ...

    def _check_for_resync(self, state_machine):
        """
        [NEW] 检查并执行时间同步的核心逻辑。这是 Scheduler 作为“响应器”的关键。
        """
        if self.context.resync_requested:
            self.context.logger.info("响应同步请求，正在命令引擎重新校准时间...")
            self.context.engine._synchronize_to_realtime()
            state_machine['daily_flags'] = { k: False for k in state_machine['daily_flags'] }
            state_machine['last_handle_bar_dt'] = self.context.current_dt
            state_machine['last_known_date'] = self.context.current_dt.date()
            self.context.resync_requested = False
            return True, state_machine
        return False, state_machine

    def _run_simulation(self):
        """[MODIFIED] 模拟盘实时循环，增加市场阶段管理和响应式自愈"""
        self.context.logger.info("模拟盘模式启动，基于真实时间运行...")
        
        state_machine = {
            'daily_flags': {'before_trading_done': False, 'after_trading_done': False, 'settle_done': False},
            'last_handle_bar_dt': self.context.current_dt or datetime(1970, 1, 1),
            'last_known_date': self.context.current_dt.date() if self.context.current_dt else date(1970, 1, 1)
        }
        
        hooks = self.lifecycle_config.get('hooks', {}); before_trading_time = datetime.strptime(hooks.get('before_trading', '09:15:00'), '%H:%M:%S').time(); after_trading_time = datetime.strptime(hooks.get('after_trading', '15:05:00'), '%H:%M:%S').time(); broker_settle_time = datetime.strptime(hooks.get('broker_settle', '15:30:00'), '%H:%M:%S').time();
        sessions = self.lifecycle_config.get('trading_sessions', []); trading_sessions = [(datetime.strptime(s, '%H:%M:%S').time(), datetime.strptime(e, '%H:%M:%S').time()) for s, e in sessions]

        while self.context.is_running:
            now = datetime.now()
            
            if now.date() > state_machine['last_known_date']:
                self.context.logger.info(f"--- 新交易日: {now.strftime('%Y-%m-%d')} ---")
                state_machine['daily_flags'] = {'before_trading_done': False, 'after_trading_done': False, 'settle_done': False}
                state_machine['last_known_date'] = now.date()
                state_machine['last_handle_bar_dt'] = datetime.combine(now.date(), time(0,0))
                self.context.strategy_error_today = False # 重置每日错误标志
                # ... (其他每日重置) ...

            self.context.current_dt = now
            is_trading_day = self.time_manager.is_trading_day(now)

            if is_trading_day:
                current_time = now.time()
                if current_time < before_trading_time: self.context.market_phase = 'CLOSED'
                elif current_time < trading_sessions[0][0]: self.context.market_phase = 'BEFORE_TRADING'
                elif any(start <= current_time <= end for start, end in trading_sessions): self.context.market_phase = 'TRADING'
                elif current_time > trading_sessions[-1][1] and current_time < after_trading_time: self.context.market_phase = 'TRADING'
                elif current_time < broker_settle_time: self.context.market_phase = 'AFTER_TRADING'
                else: self.context.market_phase = 'SETTLEMENT'

                if self.context.market_phase == 'BEFORE_TRADING' and not state_machine['daily_flags'].get('before_trading_done'):
                    self.lifecycle_manager.call_before_trading(); synced, state_machine = self._check_for_resync(state_machine);
                    if synced: continue
                    state_machine['daily_flags']['before_trading_done'] = True; self._maybe_update_server()

                if self.context.market_phase == 'TRADING' and state_machine['daily_flags'].get('before_trading_done'):
                    current_bar_dt = now.replace(second=0, microsecond=0)
                    if current_bar_dt > state_machine['last_handle_bar_dt']:
                        self.lifecycle_manager.call_handle_bar(); synced, state_machine = self._check_for_resync(state_machine)
                        if synced: continue
                        self.matching_engine.match_orders(now); state_machine['last_handle_bar_dt'] = current_bar_dt; 
                        if self._enable_intraday_statistics: self._update_intraday_statistics(now); self._maybe_update_server()
                
                if self.context.market_phase == 'AFTER_TRADING' and not state_machine['daily_flags'].get('after_trading_done'):
                    self.lifecycle_manager.call_after_trading(); synced, state_machine = self._check_for_resync(state_machine)
                    if synced: continue
                    state_machine['daily_flags']['after_trading_done'] = True
                
                if self.context.market_phase == 'SETTLEMENT' and not state_machine['daily_flags'].get('settle_done'):
                    self.matching_engine.settle(); self.lifecycle_manager.call_broker_settle(); synced, state_machine = self._check_for_resync(state_machine)
                    if synced: continue
                    self.context.benchmark_manager.update_daily(); state_machine['daily_flags']['settle_done'] = True
            else:
                self.context.market_phase = 'CLOSED'

            if not self._check_and_handle_requests(): break
            time_module.sleep(1)

        self.lifecycle_manager.call_on_end()
        self.context.logger.info("模拟盘运行结束")

    # ... (_maybe_update_server, _build_schedule_points, _update_intraday_statistics 保持不变) ...
```

#### **6. `qtrader/analysis/integrated_server.py` (已修改)**
```python
# qtrader/analysis/integrated_server.py
# ... (imports) ...

class IntegratedServer:
    # ... (__init__ 和其他方法) ...

    def _collect_overview_data(self) -> Dict[str, Any]:
        """[MODIFIED] 收集概览数据，增加模式和错误状态"""
        try:
            # ... (原有代码不变) ...

            # [MODIFIED] 在返回的字典中增加新的状态字段
            return {
                'strategy_name': self.context.strategy_name,
                # 明确传递 mode, market_phase, strategy_error_today
                'mode': self.context.mode, 
                'market_phase': self.context.market_phase,
                'strategy_error_today': self.context.strategy_error_today,
                
                'frequency': self.context.frequency,
                'current_dt': self.context.current_dt.isoformat() if self.context.current_dt else None,
                'is_running': self.context.is_running, 'is_paused': self.context.is_paused,
                'start_date': self.context.start_date, 'end_date': self.context.end_date,
                'portfolio': {
                    # ...
                },
                'benchmark': { 
                    # ...
                },
                'equity_curve': chart_data,
                'intraday_equity': {
                    # ...
                },
                'risk_metrics': self._calculate_risk_metrics(),
            }
        
        except Exception as e:
            self.context.logger.warning(f"收集概览数据失败: {e}")
            return {}
            
    # ... (其他方法保持不变) ...
```

#### **7. `qtrader/analysis/templates/integrated_monitor.html` (已修改)**
```html
<!DOCTYPE html>
<html lang="zh-CN">
<!-- ... (head 和 style 保持不变) ... -->
<body>
    <div class="container">
        <!-- [NEW] 策略错误告警横幅 -->
        <div id="error-banner" style="display: none; background-color: #fef2f2; color: #dc2626; padding: 12px 16px; border-radius: 8px; margin-bottom: 20px; font-weight: 500; border: 1px solid #fecaca;">
            检测到策略代码今日运行时发生错误！请立即检查 <a href="#" onclick="openTab(event, 'logs')" style="color: #b91c1c; font-weight: 600; text-decoration: underline;">运行日志</a> 以定位问题。
        </div>

        <div class="header">
            <!-- ... (header-left) ... -->
            <div class="header-right">
                <!-- ... (status badge, control buttons, theme toggle) ... -->
            </div>
        </div>
        
        <!-- ... (tabs 和 tab-content 保持不变) ... -->
    </div>

    <script>
        // ... (大部分 JS 保持不变) ...

        function updateUI(data) {
            window.currentData = data;
            const ov = data.overview;
            if (ov && ov.portfolio) {
                // [MODIFIED] 根据新的上下文信息更新UI
                const isSimulation = ov.mode === 'simulation';
                
                // 1. 更新标题和副标题
                document.getElementById('main-title').textContent = IS_STATIC_REPORT 
                    ? `QTrader 回测报告: ${ov.strategy_name||''}` 
                    : `QTrader 实时监控`;
                
                const modeText = isSimulation ? `模拟交易 (${ov.market_phase || '...'})` : '历史回测';
                document.getElementById('header-info').innerHTML = `策略: <strong>${ov.strategy_name||'-'}</strong> | 模式: <strong>${modeText}</strong> | 周期: ${ov.start_date||'-'} to ${ov.end_date||'N/A'} | 初始资金: <strong>${formatCurrency(ov.portfolio.initial_cash)}</strong>`;
                
                // 2. 更新按钮文本
                if (!IS_STATIC_REPORT) {
                    const btnStop = document.getElementById('btn-stop');
                    if(btnStop) btnStop.textContent = isSimulation ? '中断' : '停止';
                    // ... (pause/resume 按钮逻辑不变) ...
                }
                
                // 3. 显示/隐藏错误横幅
                const errorBanner = document.getElementById('error-banner');
                if(errorBanner) {
                    errorBanner.style.display = ov.strategy_error_today ? 'block' : 'none';
                }

                // ... (其余UI更新逻辑保持不变) ...
            }
            // ... (其余UI更新逻辑保持不变) ...
        }

        // ... (其余 JS 保持不变) ...
    </script>
</body>
</html>
```