# 基于股市数据API的量化交易框架设计文档

## 目录

1. [系统概述](#1-系统概述)
2. [核心设计理念](#2-核心设计理念)
3. [系统架构设计](#3-系统架构设计)
4. [核心模块详细设计](#4-核心模块详细设计)
5. [数据工具层设计](#5-数据工具层设计)
6. [交易撮合机制](#6-交易撮合机制)
7. [时间与调度系统](#7-时间与调度系统)
8. [状态管理与持久化](#8-状态管理与持久化)
9. [回测与模拟盘模式](#9-回测与模拟盘模式)
10. [可视化与报告](#10-可视化与报告)
11. [扩展性设计](#11-扩展性设计)
12. [实施路线图](#12-实施路线图)

---

## 1. 系统概述

### 1.1 设计目标

构建一个**轻量级、高度解耦、专注于交易逻辑**的量化交易框架，具备以下特点：

- **数据完全解耦**：框架不自带数据系统，用户通过工具层自定义数据获取方式
- **回测/模拟统一**：同一策略代码可无缝切换回测与模拟盘模式
- **事件驱动架构**：清晰的生命周期钩子（初始化、盘前、盘中、盘后）
- **精简撮合机制**：仅支持限价单和市价单，使用ask1/bid1+滑点撮合
- **状态可持久化**：支持暂停/恢复，便于长期运行
- **多频率支持**：支持日频、分钟频、Tick频（3秒）

### 1.2 核心差异化特性

相比现有框架（如Zipline、Backtrader、QFF），本框架的核心差异：

| 特性 | 本框架 | Zipline | QFF |
|------|--------|---------|-----|
| 数据获取 | 用户自定义工具层 | 预下载Bundle | MongoDB预存 |
| 数据依赖 | 仅交易日历+成交价+基准 | 全量历史数据 | 全量历史数据 |
| 撮合机制 | ask1/bid1+滑点 | 简化撮合 | 分钟/日线撮合 |
| 框架职责 | 纯交易逻辑 | 数据+交易 | 数据+交易 |
| 扩展性 | 极高（数据层可完全替换） | 中等 | 中等 |

### 1.3 框架不负责的部分

**明确声明：本框架不提供以下功能**

1. **因子计算**：不内置任何技术指标或因子计算
2. **选股逻辑**：不提供股票筛选工具
3. **数据下载**：不负责数据获取和存储
4. **实盘下单**：仅支持模拟盘，不对接券商API

**用户需要自行实现**：

- 数据工具层（通过Stock API或其他数据源）
- 策略逻辑（选股、择时、仓位管理）
- 因子库（如需使用）

---

## 2. 核心设计理念

### 2.1 架构原则

1. **框架与数据解耦**
   - 框架只定义数据接口规范
   - 用户通过工具层实现具体数据获取逻辑
   - 框架仅关心交易必需的数据：交易日历、成交价格、涨跌停价、基准行情

2. **事件驱动**
   - 框架核心是事件调度器
   - 策略通过注册回调函数响应事件

3. **最小惊讶原则**
   - API设计直观，符合直觉
   - 默认行为安全（如T+1自动处理）

4. **职责单一**
   - 框架只负责：时间推进、订单管理、撮合成交、账户更新、绩效统计
   - 其他功能（数据、因子、选股）由用户或第三方库提供

### 2.2 分层架构

```
┌─────────────────────────────────────────┐
│         策略层 (Strategy Layer)          │
│  - 用户策略代码                          │
│  - 生命周期钩子实现                       │
│  - 自定义数据工具使用                     │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│       框架核心层 (Core Framework)        │
│  - 事件调度器 (Event Scheduler)          │
│  - 时间管理器 (Time Manager)             │
│  - 账户管理器 (Account Manager)          │
│  - 订单管理器 (Order Manager)            │
│  - 撮合引擎 (Matching Engine)            │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      数据工具层 (Data Tools - 用户实现)   │
│  - 交易日历工具 (Trading Calendar)       │
│  - 价格数据工具 (Price Data)             │
│  - 基准数据工具 (Benchmark Data)         │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│        数据源 (Data Source - 用户选择)    │
│  - Stock API SDK                        │
│  - 本地文件                              │
│  - 数据库                                │
│  - 其他数据源                            │
└─────────────────────────────────────────┘
```

---

## 3. 系统架构设计

### 3.1 整体架构图

```
┌───────────────────────────────────────────────────────────┐
│                       用户策略代码                         │
│  class MyStrategy:                                        │
│      def initialize(context):                             │
│      def before_trading(context, data):                   │
│      def handle_bar(context, data):                       │
│      def after_trading(context, data):                    │
└───────────────────────────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────┐
│                    事件调度器核心                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │ Time        │  │ Event       │  │ Lifecycle   │      │
│  │ Manager     │→ │ Dispatcher  │→ │ Hooks       │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└───────────────────────────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────┐
│                    核心业务模块                            │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐     │
│  │ Account      │ │ Order        │ │ Matching     │     │
│  │ Manager      │ │ Manager      │ │ Engine       │     │
│  └──────────────┘ └──────────────┘ └──────────────┘     │
│  ┌──────────────┐ ┌──────────────┐                      │
│  │ Position     │ │ Performance  │                      │
│  │ Manager      │ │ Analyzer     │                      │
│  └──────────────┘ └──────────────┘                      │
└───────────────────────────────────────────────────────────┘
                            ↓
┌───────────────────────────────────────────────────────────┐
│              数据工具接口（用户实现）                       │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐     │
│  │ Calendar     │ │ Price        │ │ Benchmark    │     │
│  │ Tool         │ │ Tool         │ │ Tool         │     │
│  └──────────────┘ └──────────────┘ └──────────────┘     │
└───────────────────────────────────────────────────────────┘
```

### 3.2 目录结构

```
quant_framework/
├── core/                      # 核心框架
│   ├── __init__.py
│   ├── context.py            # 全局上下文对象
│   ├── engine.py             # 主引擎
│   ├── scheduler.py          # 事件调度器
│   ├── time_manager.py       # 时间管理器
│   ├── lifecycle.py          # 生命周期管理
│   └── config.py             # 配置管理
│
├── trading/                   # 交易核心
│   ├── __init__.py
│   ├── account.py            # 账户管理
│   ├── order.py              # 订单对象
│   ├── order_manager.py      # 订单管理器
│   ├── position.py           # 持仓对象
│   ├── position_manager.py   # 持仓管理器
│   ├── matching_engine.py    # 撮合引擎
│   ├── commission.py         # 手续费计算
│   └── slippage.py           # 滑点模型
│
├── data_tools/                # 数据工具接口（用户实现）
│   ├── __init__.py
│   ├── base.py               # 数据工具基类
│   ├── calendar.py           # 交易日历工具接口
│   ├── price.py              # 价格数据工具接口
│   ├── benchmark.py          # 基准数据工具接口
│   └── examples/             # 示例实现
│       ├── api_calendar.py   # 基于API的日历实现
│       ├── api_price.py      # 基于API的价格实现
│       └── api_benchmark.py  # 基于API的基准实现
│
├── strategy/                  # 策略相关
│   ├── __init__.py
│   ├── base.py               # 策略基类
│   ├── context.py            # 策略上下文
│   └── api.py                # 策略API
│
├── analysis/                  # 分析模块
│   ├── __init__.py
│   ├── performance.py        # 绩效分析
│   ├── risk.py               # 风险分析
│   ├── report.py             # 报告生成
│   └── visualizer.py         # 可视化
│
├── utils/                     # 工具模块
│   ├── __init__.py
│   ├── logger.py             # 日志工具
│   ├── serializer.py         # 序列化工具
│   ├── validator.py          # 参数验证
│   └── helpers.py            # 辅助函数
│
├── configs/                   # 配置文件
│   ├── default.yaml          # 默认配置
│   ├── backtest.yaml         # 回测配置
│   └── simulation.yaml       # 模拟盘配置
│
├── examples/                  # 示例策略
│   ├── simple_ma.py          # 简单均线策略
│   ├── data_tools_impl/      # 数据工具示例实现
│   │   ├── stock_api_tools.py
│   │   └── local_file_tools.py
│   └── README.md
│
├── tests/                     # 测试
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── setup.py
├── requirements.txt
└── README.md
```

---

## 4. 核心模块详细设计

### 4.1 Context（全局上下文）

#### 4.1.1 设计目标

提供一个全局单例对象，存储回测/模拟盘运行中的所有状态信息。

#### 4.1.2 核心属性

```python
# core/context.py

from datetime import datetime
from typing import Dict, Any, Optional
from dataclasses import dataclass, field

@dataclass
class Context:
    """全局上下文对象"""
    
    # 基础信息
    mode: str = 'backtest'  # 'backtest' 或 'simulation'
    strategy_name: str = ''
    start_date: str = ''
    end_date: str = ''
    current_dt: Optional[datetime] = None
    
    # 频率设置
    frequency: str = 'daily'  # 'daily', 'minute', 'tick'
    
    # 账户相关
    portfolio: Optional['Portfolio'] = None
    
    # 订单与持仓
    order_manager: Optional['OrderManager'] = None
    position_manager: Optional['PositionManager'] = None
    
    # 配置
    config: Dict[str, Any] = field(default_factory=dict)
    
    # 用户自定义数据存储
    user_data: Dict[str, Any] = field(default_factory=dict)
    
    # 运行状态
    is_running: bool = False
    is_paused: bool = False
    
    # 性能追踪
    performance: Optional['Performance'] = None
    
    # 日志
    logger: Optional['Logger'] = None
    
    # 数据工具（用户注入）
    calendar_tool: Optional['CalendarTool'] = None
    price_tool: Optional['PriceTool'] = None
    benchmark_tool: Optional['BenchmarkTool'] = None
    
    def __post_init__(self):
        """初始化后处理"""
        if self.current_dt is None:
            self.current_dt = datetime.now()
    
    def get(self, key: str, default: Any = None) -> Any:
        """获取用户自定义数据"""
        return self.user_data.get(key, default)
    
    def set(self, key: str, value: Any):
        """设置用户自定义数据"""
        self.user_data[key] = value
    
    def register_data_tools(
        self,
        calendar_tool,
        price_tool,
        benchmark_tool
    ):
        """注册数据工具（用户调用）"""
        self.calendar_tool = calendar_tool
        self.price_tool = price_tool
        self.benchmark_tool = benchmark_tool
```

#### 4.1.3 使用示例

```python
# 在策略中访问
def handle_bar(context, data):
    # 获取当前时间
    current_time = context.current_dt
    
    # 获取账户信息
    cash = context.portfolio.cash
    
    # 自定义数据存储
    context.set('my_indicator', 0.5)
    indicator = context.get('my_indicator')
```

---

### 4.2 Engine（主引擎）

#### 4.2.1 职责

- 初始化所有核心组件
- 协调各模块运行
- 控制回测/模拟盘流程

#### 4.2.2 核心实现

```python
# core/engine.py

from typing import Type, Optional
import yaml
from datetime import datetime
from .context import Context
from .scheduler import Scheduler
from .time_manager import TimeManager
from ..trading.account import Portfolio
from ..trading.order_manager import OrderManager
from ..trading.position_manager import PositionManager
from ..trading.matching_engine import MatchingEngine
from ..strategy.base import Strategy
from ..utils.logger import Logger

class Engine:
    """框架主引擎"""
    
    def __init__(self, config_path: Optional[str] = None):
        # 加载配置
        self.config = self._load_config(config_path)
        
        # 初始化日志
        self.logger = Logger(self.config.get('logging', {}))
        
        # 初始化上下文
        self.context = Context(
            mode=self.config['mode'],
            frequency=self.config['frequency'],
            config=self.config,
            logger=self.logger
        )
        
        # 初始化组件
        self._init_components()
    
    def _load_config(self, config_path: Optional[str]) -> dict:
        """加载配置文件"""
        if config_path is None:
            config_path = 'configs/default.yaml'
        
        with open(config_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        
        return config
    
    def _init_components(self):
        """初始化所有核心组件"""
        # 时间管理器（依赖用户注入的日历工具）
        self.time_manager = TimeManager(self.context)
        
        # 账户
        self.context.portfolio = Portfolio(
            initial_cash=self.config['initial_cash']
        )
        
        # 订单与持仓
        self.context.order_manager = OrderManager(self.context)
        self.context.position_manager = PositionManager(self.context)
        
        # 撮合引擎
        self.matching_engine = MatchingEngine(
            self.context,
            self.config['matching']
        )
        
        # 调度器
        self.scheduler = Scheduler(
            self.context,
            self.time_manager,
            self.matching_engine
        )
    
    def run(
        self,
        strategy_class: Type[Strategy],
        calendar_tool,
        price_tool,
        benchmark_tool,
        **kwargs
    ):
        """
        运行策略
        
        Args:
            strategy_class: 策略类
            calendar_tool: 交易日历工具实例
            price_tool: 价格数据工具实例
            benchmark_tool: 基准数据工具实例
            **kwargs: 其他参数（如start_date, end_date）
        """
        # 注册数据工具
        self.context.register_data_tools(
            calendar_tool,
            price_tool,
            benchmark_tool
        )
        
        # 验证数据工具
        self._validate_data_tools()
        
        # 实例化策略
        strategy = strategy_class()
        
        # 注册生命周期钩子
        self.scheduler.register_strategy(strategy)
        
        # 设置时间范围
        self.context.start_date = kwargs.get('start_date', self.config.get('start_date'))
        self.context.end_date = kwargs.get('end_date', self.config.get('end_date'))
        self.context.strategy_name = kwargs.get('strategy_name', strategy.__class__.__name__)
        
        # 启动调度器
        self.context.is_running = True
        self.logger.info(f"开始运行策略: {self.context.strategy_name}")
        self.logger.info(f"模式: {self.context.mode}, 频率: {self.context.frequency}")
        
        try:
            self.scheduler.run()
        except KeyboardInterrupt:
            self.logger.warning("用户中断运行")
            self.pause()
        except Exception as e:
            self.logger.error(f"运行出错: {e}", exc_info=True)
            raise
        finally:
            self.context.is_running = False
    
    def _validate_data_tools(self):
        """验证数据工具是否已注册"""
        if self.context.calendar_tool is None:
            raise RuntimeError("未注册交易日历工具，请调用context.register_data_tools()")
        
        if self.context.price_tool is None:
            raise RuntimeError("未注册价格数据工具，请调用context.register_data_tools()")
        
        if self.context.benchmark_tool is None:
            raise RuntimeError("未注册基准数据工具，请调用context.register_data_tools()")
    
    def pause(self):
        """暂停运行"""
        self.context.is_paused = True
        self.logger.info("暂停运行，正在保存状态...")
        self._save_state()
    
    def resume(self, state_path: str):
        """从保存点恢复"""
        self.logger.info(f"从 {state_path} 恢复运行")
        self._load_state(state_path)
        self.context.is_paused = False
        self.scheduler.run()
    
    def _save_state(self):
        """保存当前状态"""
        from ..utils.serializer import StateSerializer
        serializer = StateSerializer(self.context)
        serializer.save()
    
    def _load_state(self, path: str):
        """加载状态"""
        from ..utils.serializer import StateSerializer
        serializer = StateSerializer(self.context)
        serializer.load(path)
```

---

### 4.3 Scheduler（事件调度器）

#### 4.3.1 核心职责

- 管理时间序列的推进
- 在关键时间点触发生命周期钩子
- 协调撮合引擎执行

#### 4.3.2 生命周期事件

```python
# core/scheduler.py

from datetime import datetime, time, timedelta
from typing import Optional
from .context import Context
from .time_manager import TimeManager
from ..trading.matching_engine import MatchingEngine
from ..strategy.base import Strategy

class Scheduler:
    """事件调度器"""
    
    # 定义交易时段
    MORNING_START = time(9, 30)
    MORNING_END = time(11, 30)
    AFTERNOON_START = time(13, 0)
    AFTERNOON_END = time(15, 0)
    
    def __init__(
        self,
        context: Context,
        time_manager: TimeManager,
        matching_engine: MatchingEngine
    ):
        self.context = context
        self.time_manager = time_manager
        self.matching_engine = matching_engine
        self.strategy: Optional[Strategy] = None
        
        # 根据频率构建时间点列表
        if context.frequency == 'minute':
            self.time_points = self._build_minute_schedule()
        elif context.frequency == 'tick':
            self.time_points = self._build_tick_schedule()
        else:
            self.time_points = []
    
    def register_strategy(self, strategy: Strategy):
        """注册策略"""
        self.strategy = strategy
    
    def run(self):
        """主运行循环"""
        if self.context.mode == 'backtest':
            self._run_backtest()
        else:
            self._run_simulation()
    
    def _run_backtest(self):
        """回测模式运行"""
        # 获取交易日列表
        trading_days = self.time_manager.get_trading_days(
            self.context.start_date,
            self.context.end_date
        )
        
        self.context.logger.info(f"交易日总数: {len(trading_days)}")
        
        # 调用初始化
        self._call_initialize()
        
        # 遍历每个交易日
        for idx, current_date in enumerate(trading_days):
            if not self.context.is_running or self.context.is_paused:
                break
            
            self.context.logger.info(f"回测日期: {current_date} ({idx+1}/{len(trading_days)})")
            
            # 日级别回测
            if self.context.frequency == 'daily':
                self._run_daily_bar(current_date)
            
            # 分钟级别回测
            elif self.context.frequency == 'minute':
                self._run_minute_bars(current_date)
            
            # Tick级别回测
            elif self.context.frequency == 'tick':
                self._run_tick_bars(current_date)
        
        # 调用结束钩子
        self._call_on_end()
    
    def _run_simulation(self):
        """模拟盘模式运行"""
        import time as time_module
        
        # 调用初始化
        self._call_initialize()
        
        self.context.logger.info("进入模拟盘运行模式")
        
        while self.context.is_running:
            now = datetime.now()
            
            # 判断是否在交易日
            if not self.time_manager.is_trading_day(now):
                self.context.logger.debug(f"{now.date()} 非交易日，休眠")
                time_module.sleep(60)  # 休眠1分钟后再检查
                continue
            
            # 判断当前应该执行什么事件
            if self._should_run_before_trading(now):
                self._call_before_trading(now)
            
            elif self._should_run_handle_bar(now):
                if self.context.frequency == 'daily':
                    self._call_handle_bar(now)
                    self.matching_engine.match_orders(now)
                
                elif self.context.frequency == 'minute':
                    self._call_handle_bar(now)
                    self.matching_engine.match_orders(now)
                
                elif self.context.frequency == 'tick':
                    self._call_handle_bar(now)
                    self.matching_engine.match_orders(now)
            
            elif self._should_run_after_trading(now):
                self._call_after_trading(now)
                self.matching_engine.settle()
                self.context.logger.info("当日结算完成")
            
            # 休眠到下一个事件点
            self._sleep_until_next_event()
    
    def _run_daily_bar(self, date: str):
        """执行单日回测（日频）"""
        # 设置当前时间为开盘时刻
        dt = datetime.strptime(f"{date} 09:30:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt
        
        # 盘前
        self._call_before_trading(dt)
        
        # 盘中（日频只调用一次）
        self._call_handle_bar(dt)
        
        # 撮合（使用收盘价）
        self.matching_engine.match_orders(dt)
        
        # 盘后
        dt_close = datetime.strptime(f"{date} 15:00:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_close
        self._call_after_trading(dt_close)
        
        # 结算
        self.matching_engine.settle()
    
    def _run_minute_bars(self, date: str):
        """执行单日回测（分钟频）"""
        # 盘前
        dt_before = datetime.strptime(f"{date} 09:25:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_before
        self._call_before_trading(dt_before)
        
        # 遍历分钟时间点
        for minute_str in self.time_points:
            dt = datetime.strptime(f"{date} {minute_str}", "%Y-%m-%d %H:%M:%S")
            self.context.current_dt = dt
            
            # 调用handle_bar
            self._call_handle_bar(dt)
            
            # 撮合
            self.matching_engine.match_orders(dt)
            
            if self.context.is_paused:
                break
        
        # 盘后
        dt_after = datetime.strptime(f"{date} 15:00:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_after
        self._call_after_trading(dt_after)
        
        # 结算
        self.matching_engine.settle()
    
    def _run_tick_bars(self, date: str):
        """执行单日回测（Tick频，3秒一次）"""
        # 盘前
        dt_before = datetime.strptime(f"{date} 09:25:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_before
        self._call_before_trading(dt_before)
        
        # 遍历Tick时间点
        for tick_str in self.time_points:
            dt = datetime.strptime(f"{date} {tick_str}", "%Y-%m-%d %H:%M:%S")
            self.context.current_dt = dt
            
            # 调用handle_bar
            self._call_handle_bar(dt)
            
            # 撮合
            self.matching_engine.match_orders(dt)
            
            if self.context.is_paused:
                break
        
        # 盘后
        dt_after = datetime.strptime(f"{date} 15:00:00", "%Y-%m-%d %H:%M:%S")
        self.context.current_dt = dt_after
        self._call_after_trading(dt_after)
        
        # 结算
        self.matching_engine.settle()
    
    def _build_minute_schedule(self) -> list:
        """构建分钟时间点列表"""
        schedule = []
        
        # 上午时段
        current = datetime.combine(datetime.today(), self.MORNING_START)
        end = datetime.combine(datetime.today(), self.MORNING_END)
        while current <= end:
            schedule.append(current.strftime("%H:%M:%S"))
            current += timedelta(minutes=1)
        
        # 下午时段
        current = datetime.combine(datetime.today(), self.AFTERNOON_START)
        end = datetime.combine(datetime.today(), self.AFTERNOON_END)
        while current <= end:
            schedule.append(current.strftime("%H:%M:%S"))
            current += timedelta(minutes=1)
        
        return schedule
    
    def _build_tick_schedule(self) -> list:
        """构建Tick时间点列表（3秒一次）"""
        schedule = []
        
        # 上午时段
        current = datetime.combine(datetime.today(), self.MORNING_START)
        end = datetime.combine(datetime.today(), self.MORNING_END)
        while current <= end:
            schedule.append(current.strftime("%H:%M:%S"))
            current += timedelta(seconds=3)
        
        # 下午时段
        current = datetime.combine(datetime.today(), self.AFTERNOON_START)
        end = datetime.combine(datetime.today(), self.AFTERNOON_END)
        while current <= end:
            schedule.append(current.strftime("%H:%M:%S"))
            current += timedelta(seconds=3)
        
        return schedule
    
    def _call_initialize(self):
        """调用初始化钩子"""
        if hasattr(self.strategy, 'initialize'):
            self.context.logger.info("调用策略初始化")
            self.strategy.initialize(self.context)
    
    def _call_before_trading(self, dt: datetime):
        """调用盘前钩子"""
        if hasattr(self.strategy, 'before_trading'):
            data = self._get_data_proxy(dt)
            self.strategy.before_trading(self.context, data)
    
    def _call_handle_bar(self, dt: datetime):
        """调用盘中钩子"""
        if hasattr(self.strategy, 'handle_bar'):
            data = self._get_data_proxy(dt)
            self.strategy.handle_bar(self.context, data)
    
    def _call_after_trading(self, dt: datetime):
        """调用盘后钩子"""
        if hasattr(self.strategy, 'after_trading'):
            data = self._get_data_proxy(dt)
            self.strategy.after_trading(self.context, data)
    
    def _call_on_end(self):
        """调用结束钩子"""
        if hasattr(self.strategy, 'on_end'):
            self.context.logger.info("调用策略结束钩子")
            self.strategy.on_end(self.context)
    
    def _get_data_proxy(self, dt: datetime):
        """获取数据代理对象"""
        from ..strategy.data_proxy import DataProxy
        return DataProxy(self.context, dt)
    
    def _should_run_before_trading(self, now: datetime) -> bool:
        """判断是否应该执行盘前"""
        # 模拟盘：在9:25执行
        return now.time() >= time(9, 25) and now.time() < time(9, 26)
    
    def _should_run_handle_bar(self, now: datetime) -> bool:
        """判断是否应该执行盘中"""
        current_time = now.time()
        
        # 判断是否在交易时段
        in_trading_hours = (
            (self.MORNING_START <= current_time <= self.MORNING_END) or
            (self.AFTERNOON_START <= current_time <= self.AFTERNOON_END)
        )
        
        if not in_trading_hours:
            return False
        
        # 日频：在开盘时执行
        if self.context.frequency == 'daily':
            return current_time >= self.MORNING_START and current_time < time(9, 31)
        
        # 分钟频：每分钟整点执行
        elif self.context.frequency == 'minute':
            return now.second == 0
        
        # Tick频：每3秒执行
        elif self.context.frequency == 'tick':
            return now.second % 3 == 0
        
        return False
    
    def _should_run_after_trading(self, now: datetime) -> bool:
        """判断是否应该执行盘后"""
        # 模拟盘：在15:01执行
        return now.time() >= time(15, 1) and now.time() < time(15, 2)
    
    def _sleep_until_next_event(self):
        """休眠到下一个事件点"""
        import time as time_module
        
        if self.context.frequency == 'tick':
            # Tick频：休眠3秒
            time_module.sleep(3)
        elif self.context.frequency == 'minute':
            # 分钟频：休眠到下一分钟
            now = datetime.now()
            time_module.sleep(max(60 - now.second, 1))
        else:
            # 日频：休眠5秒后再检查
            time_module.sleep(5)
```

---

### 4.4 TimeManager（时间管理器）

#### 4.4.1 职责

- 管理交易日历（通过用户注入的日历工具）
- 判断交易时段
- 提供时间相关工具函数

#### 4.4.2 核心实现

```python
# core/time_manager.py

from datetime import datetime, time
from typing import List, Optional
from .context import Context

class TimeManager:
    """时间管理器"""
    
    # 交易时段定义（可配置）
    MORNING_START = time(9, 30)
    MORNING_END = time(11, 30)
    AFTERNOON_START = time(13, 0)
    AFTERNOON_END = time(15, 0)
    
    def __init__(self, context: Context):
        self.context = context
    
    def is_trading_day(self, dt: datetime) -> bool:
        """判断是否为交易日（依赖用户注入的日历工具）"""
        if self.context.calendar_tool is None:
            raise RuntimeError("未注册交易日历工具")
        
        date_str = dt.strftime('%Y-%m-%d')
        return self.context.calendar_tool.is_trading_day(date_str)
    
    def is_trading_time(self, dt: datetime) -> bool:
        """判断是否在交易时段"""
        if not self.is_trading_day(dt):
            return False
        
        current_time = dt.time()
        return (
            (self.MORNING_START <= current_time <= self.MORNING_END) or
            (self.AFTERNOON_START <= current_time <= self.AFTERNOON_END)
        )
    
    def get_trading_days(self, start: str, end: str) -> List[str]:
        """获取交易日列表（依赖用户注入的日历工具）"""
        if self.context.calendar_tool is None:
            raise RuntimeError("未注册交易日历工具")
        
        return self.context.calendar_tool.get_trading_days(start, end)
    
    def get_previous_trading_day(
        self,
        dt: datetime,
        n: int = 1
    ) -> Optional[str]:
        """获取前N个交易日"""
        if self.context.calendar_tool is None:
            raise RuntimeError("未注册交易日历工具")
        
        return self.context.calendar_tool.get_previous_trading_day(
            dt.strftime('%Y-%m-%d'),
            n
        )
    
    def get_next_trading_day(
        self,
        dt: datetime,
        n: int = 1
    ) -> Optional[str]:
        """获取后N个交易日"""
        if self.context.calendar_tool is None:
            raise RuntimeError("未注册交易日历工具")
        
        return self.context.calendar_tool.get_next_trading_day(
            dt.strftime('%Y-%m-%d'),
            n
        )
```

---

## 5. 数据工具层设计

### 5.1 设计理念

**核心原则**：框架不提供任何数据获取实现，仅定义接口规范。用户需要根据自己的数据源实现这些接口。

**框架需要的数据**：

1. **交易日历**：判断是否为交易日、获取交易日列表
2. **价格数据**：获取成交价格、ask1/bid1、涨跌停价
3. **基准数据**：获取基准指数行情

**不需要的数据**：

- 因子数据
- 财务数据
- 选股数据
- 其他任何非交易必需的数据

---

### 5.2 交易日历工具接口

```python
# data_tools/calendar.py

from abc import ABC, abstractmethod
from typing import List, Optional

class CalendarTool(ABC):
    """
    交易日历工具基类
    
    用户需要继承此类并实现所有抽象方法
    """
    
    @abstractmethod
    def is_trading_day(self, date: str) -> bool:
        """
        判断是否为交易日
        
        Args:
            date: 日期字符串，格式 'YYYY-MM-DD'
        
        Returns:
            True表示是交易日，False表示非交易日
        """
        pass
    
    @abstractmethod
    def get_trading_days(self, start: str, end: str) -> List[str]:
        """
        获取时间范围内的所有交易日
        
        Args:
            start: 开始日期，格式 'YYYY-MM-DD'
            end: 结束日期，格式 'YYYY-MM-DD'
        
        Returns:
            交易日列表，格式 ['YYYY-MM-DD', ...]
        """
        pass
    
    @abstractmethod
    def get_previous_trading_day(self, date: str, n: int = 1) -> Optional[str]:
        """
        获取前N个交易日
        
        Args:
            date: 基准日期，格式 'YYYY-MM-DD'
            n: 前推天数
        
        Returns:
            前N个交易日，格式 'YYYY-MM-DD'，不存在则返回None
        """
        pass
    
    @abstractmethod
    def get_next_trading_day(self, date: str, n: int = 1) -> Optional[str]:
        """
        获取后N个交易日
        
        Args:
            date: 基准日期，格式 'YYYY-MM-DD'
            n: 后推天数
        
        Returns:
            后N个交易日，格式 'YYYY-MM-DD'，不存在则返回None
        """
        pass
```

---

### 5.3 价格数据工具接口

```python
# data_tools/price.py

from abc import ABC, abstractmethod
from typing import Dict, Optional
from datetime import datetime

class PriceTool(ABC):
    """
    价格数据工具基类
    
    用户需要继承此类并实现所有抽象方法
    """
    
    @abstractmethod
    def get_price(
        self,
        symbol: str,
        dt: datetime,
        frequency: str
    ) -> Optional[Dict]:
        """
        获取指定时刻的价格数据
        
        Args:
            symbol: 股票代码（不带后缀）
            dt: 时间点
            frequency: 频率 'daily', 'minute', 'tick'
        
        Returns:
            价格数据字典，格式:
            {
                'current_price': float,  # 当前价格（必需）
                'ask1': float,           # 卖一价（可选，撮合时使用）
                'bid1': float,           # 买一价（可选，撮合时使用）
            }
            
            如果数据不存在，返回None
        """
        pass
    
    @abstractmethod
    def get_limit_price(
        self,
        symbol: str,
        date: str
    ) -> Optional[Dict]:
        """
        获取涨跌停价格
        
        Args:
            symbol: 股票代码（不带后缀）
            date: 日期，格式 'YYYY-MM-DD'
        
        Returns:
            涨跌停价格字典，格式:
            {
                'high_limit': float,  # 涨停价
                'low_limit': float,   # 跌停价
            }
            
            如果数据不存在，返回None
        """
        pass
    
    @abstractmethod
    def is_suspended(
        self,
        symbol: str,
        date: str
    ) -> bool:
        """
        判断是否停牌
        
        Args:
            symbol: 股票代码（不带后缀）
            date: 日期，格式 'YYYY-MM-DD'
        
        Returns:
            True表示停牌，False表示正常交易
        """
        pass
```

---

### 5.4 基准数据工具接口

```python
# data_tools/benchmark.py

from abc import ABC, abstractmethod
from typing import Dict, Optional
from datetime import datetime

class BenchmarkTool(ABC):
    """
    基准数据工具基类
    
    用户需要继承此类并实现所有抽象方法
    """
    
    @abstractmethod
    def get_benchmark_price(
        self,
        symbol: str,
        dt: datetime
    ) -> Optional[float]:
        """
        获取基准指数价格
        
        Args:
            symbol: 指数代码
            dt: 时间点
        
        Returns:
            指数价格，如果不存在返回None
        """
        pass
    
    @abstractmethod
    def get_benchmark_return(
        self,
        symbol: str,
        start: str,
        end: str
    ) -> Optional[float]:
        """
        获取基准指数收益率
        
        Args:
            symbol: 指数代码
            start: 开始日期，格式 'YYYY-MM-DD'
            end: 结束日期，格式 'YYYY-MM-DD'
        
        Returns:
            收益率（小数形式），如果不存在返回None
        """
        pass
```

---

### 5.5 示例实现：基于Stock API

#### 5.5.1 交易日历工具实现

```python
# data_tools/examples/api_calendar.py

import os
import json
from typing import List, Optional
from datetime import datetime, timedelta
from ..calendar import CalendarTool

class APICalendarTool(CalendarTool):
    """
    基于Stock API的交易日历工具实现
    
    特点：
    1. 本地缓存交易日历数据
    2. 自动增量更新
    3. 支持离线使用
    """
    
    def __init__(self, api_client, cache_file: str = '.cache/calendar.json'):
        """
        Args:
            api_client: Stock API客户端实例
            cache_file: 缓存文件路径
        """
        self.api_client = api_client
        self.cache_file = cache_file
        
        # 加载本地缓存
        self.calendar_data = self._load_cache()
        
        # 自动更新
        self._auto_update()
    
    def _load_cache(self) -> dict:
        """加载缓存文件"""
        if os.path.exists(self.cache_file):
            with open(self.cache_file, 'r') as f:
                return json.load(f)
        else:
            return {
                'trading_days': [],
                'last_update': None
            }
    
    def _save_cache(self):
        """保存缓存文件"""
        os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)
        with open(self.cache_file, 'w') as f:
            json.dump(self.calendar_data, f, indent=2)
    
    def _auto_update(self):
        """自动更新交易日历"""
        last_update = self.calendar_data.get('last_update')
        
        # 如果从未更新，或者距离上次更新超过1天，则更新
        should_update = (
            last_update is None or
            datetime.now() - datetime.fromisoformat(last_update) > timedelta(days=1)
        )
        
        if should_update:
            self._fetch_and_update()
    
    def _fetch_and_update(self):
        """从API获取并更新"""
        try:
            # 确定更新范围
            if self.calendar_data['trading_days']:
                # 从最后一个交易日开始更新
                last_day = max(self.calendar_data['trading_days'])
                start_date = last_day
            else:
                # 首次更新，获取2005年至今
                start_date = '2005-01-01'
            
            # 结束日期为明年年底（确保覆盖未来）
            end_date = f"{datetime.now().year + 1}-12-31"
            
            # 调用API
            new_days = self.api_client.calendar.get_trading_days(
                start_date=start_date,
                end_date=end_date
            )
            
            # 合并去重
            all_days = set(self.calendar_data['trading_days'] + new_days)
            self.calendar_data['trading_days'] = sorted(list(all_days))
            self.calendar_data['last_update'] = datetime.now().isoformat()
            
            # 保存
            self._save_cache()
            
            print(f"交易日历更新成功，共 {len(self.calendar_data['trading_days'])} 个交易日")
            
        except Exception as e:
            print(f"更新交易日历失败: {e}")
    
    def is_trading_day(self, date: str) -> bool:
        """判断是否为交易日"""
        return date in self.calendar_data['trading_days']
    
    def get_trading_days(self, start: str, end: str) -> List[str]:
        """获取交易日列表"""
        return [
            day for day in self.calendar_data['trading_days']
            if start <= day <= end
        ]
    
    def get_previous_trading_day(self, date: str, n: int = 1) -> Optional[str]:
        """获取前N个交易日"""
        days = [d for d in self.calendar_data['trading_days'] if d < date]
        if len(days) >= n:
            return days[-n]
        return None
    
    def get_next_trading_day(self, date: str, n: int = 1) -> Optional[str]:
        """获取后N个交易日"""
        days = [d for d in self.calendar_data['trading_days'] if d > date]
        if len(days) >= n:
            return days[n - 1]
        return None
```

#### 5.5.2 价格数据工具实现

```python
# data_tools/examples/api_price.py

from typing import Dict, Optional
from datetime import datetime
from ..price import PriceTool

class APIPriceTool(PriceTool):
    """
    基于Stock API的价格数据工具实现
    
    特点：
    1. 实时从API获取数据
    2. 简单内存缓存（可选）
    """
    
    def __init__(self, api_client, enable_cache: bool = True):
        """
        Args:
            api_client: Stock API客户端实例
            enable_cache: 是否启用缓存
        """
        self.api_client = api_client
        self.enable_cache = enable_cache
        self._cache = {} if enable_cache else None
    
    def get_price(
        self,
        symbol: str,
        dt: datetime,
        frequency: str
    ) -> Optional[Dict]:
        """获取指定时刻的价格数据"""
        # 检查缓存
        if self.enable_cache:
            cache_key = f"{symbol}_{dt.isoformat()}_{frequency}"
            if cache_key in self._cache:
                return self._cache[cache_key]
        
        try:
            # 根据频率选择不同的API
            if frequency == 'tick':
                # 使用Tick API
                result = self._get_tick_price(symbol, dt)
            else:
                # 使用虚拟K线API（包含当前未完成K线）
                result = self._get_kline_price(symbol, dt, frequency)
            
            # 写入缓存
            if self.enable_cache and result:
                self._cache[cache_key] = result
            
            return result
            
        except Exception as e:
            print(f"获取价格数据失败 {symbol} @ {dt}: {e}")
            return None
    
    def _get_tick_price(self, symbol: str, dt: datetime) -> Optional[Dict]:
        """从Tick API获取价格"""
        date_str = dt.strftime('%Y-%m-%d %H:%M:%S')
        tick_data = self.api_client.market.get_tick(code=symbol, date=date_str)
        
        if tick_data and symbol in tick_data:
            data = tick_data[symbol]
            return {
                'current_price': data.get('current_price'),
                'ask1': data.get('ask1_price'),
                'bid1': data.get('bid1_price'),
            }
        
        return None
    
    def _get_kline_price(
        self,
        symbol: str,
        dt: datetime,
        frequency: str
    ) -> Optional[Dict]:
        """从虚拟K线API获取价格"""
        period = '1d' if frequency == 'daily' else '1m'
        date_str = dt.strftime('%Y-%m-%d %H:%M:%S')
        
        kline_data = self.api_client.market.get_single_vkline(
            code=symbol,
            period=period,
            date=date_str
        )
        
        if kline_data and symbol in kline_data and len(kline_data[symbol]) > 0:
            data = kline_data[symbol][0]
            current_price = data.get('current_price')
            
            return {
                'current_price': current_price,
                'ask1': None,  # K线数据无五档
                'bid1': None,
            }
        
        return None
    
    def get_limit_price(self, symbol: str, date: str) -> Optional[Dict]:
        """获取涨跌停价格"""
        try:
            result = self.api_client.market.get_limit_price(
                code=symbol,
                date=date
            )
            
            if result and symbol in result:
                data = result[symbol]
                return {
                    'high_limit': data.get('high_limit'),
                    'low_limit': data.get('low_limit'),
                }
            
            return None
            
        except Exception as e:
            print(f"获取涨跌停价格失败 {symbol} @ {date}: {e}")
            return None
    
    def is_suspended(self, symbol: str, date: str) -> bool:
        """判断是否停牌"""
        try:
            result = self.api_client.stock.is_suspended(
                code=symbol,
                date=date
            )
            
            if result and len(result) > 0:
                return result[0].get('is_suspended', False)
            
            return False
            
        except Exception as e:
            print(f"判断停牌失败 {symbol} @ {date}: {e}")
            return False
```

#### 5.5.3 基准数据工具实现

```python
# data_tools/examples/api_benchmark.py

from typing import Optional
from datetime import datetime
from ..benchmark import BenchmarkTool

class APIBenchmarkTool(BenchmarkTool):
    """
    基于Stock API的基准数据工具实现
    """
    
    def __init__(self, api_client):
        """
        Args:
            api_client: Stock API客户端实例
        """
        self.api_client = api_client
        self._cache = {}
    
    def get_benchmark_price(
        self,
        symbol: str,
        dt: datetime
    ) -> Optional[float]:
        """获取基准指数价格"""
        cache_key = f"{symbol}_{dt.isoformat()}"
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        try:
            # 使用指数虚拟K线API
            date_str = dt.strftime('%Y-%m-%d %H:%M:%S')
            result = self.api_client.index.get_index_single_vkline(
                code=symbol,
                period='1d',
                date=date_str
            )
            
            if result and symbol in result and len(result[symbol]) > 0:
                price = result[symbol][0].get('current_price')
                self._cache[cache_key] = price
                return price
            
            return None
            
        except Exception as e:
            print(f"获取基准价格失败 {symbol} @ {dt}: {e}")
            return None
    
    def get_benchmark_return(
        self,
        symbol: str,
        start: str,
        end: str
    ) -> Optional[float]:
        """获取基准指数收益率"""
        try:
            # 获取开始和结束价格
            start_dt = datetime.strptime(start, '%Y-%m-%d')
            end_dt = datetime.strptime(end, '%Y-%m-%d')
            
            start_price = self.get_benchmark_price(symbol, start_dt)
            end_price = self.get_benchmark_price(symbol, end_dt)
            
            if start_price and end_price:
                return (end_price - start_price) / start_price
            
            return None
            
        except Exception as e:
            print(f"计算基准收益率失败 {symbol} {start}-{end}: {e}")
            return None
```

---

### 5.6 使用示例

```python
# examples/data_tools_usage.py

from stock_api_sdk import StockAPIClient
from quant_framework.data_tools.examples import (
    APICalendarTool,
    APIPriceTool,
    APIBenchmarkTool
)
from quant_framework import Engine
from my_strategy import MyStrategy

# 初始化API客户端
api_client = StockAPIClient(
    base_url="http://your-api-server/api/v1",
    api_key="your_api_key"
)

# 创建数据工具实例
calendar_tool = APICalendarTool(api_client)
price_tool = APIPriceTool(api_client)
benchmark_tool = APIBenchmarkTool(api_client)

# 创建引擎
engine = Engine(config_path='configs/backtest.yaml')

# 运行策略（注入数据工具）
engine.run(
    MyStrategy,
    calendar_tool=calendar_tool,
    price_tool=price_tool,
    benchmark_tool=benchmark_tool,
    start_date='2023-01-01',
    end_date='2023-12-31'
)
```

---

## 6. 交易撮合机制

### 6.1 撮合引擎设计

#### 6.1.1 核心逻辑

**撮合规则**：

1. **价格确定**：
   - 市价单：优先使用ask1（买入）或bid1（卖出），不存在时使用current_price
   - 限价单：用户指定价格

2. **价格比较**（限价单）：
   - 买入：限价 >= ask1（或current_price），才能成交
   - 卖出：限价 <= bid1（或current_price），才能成交

3. **滑点处理**：
   - 固定滑点：按配置的百分比
   - 买入加滑点，卖出减滑点

4. **涨跌停限制**：
   - 获取涨跌停价格
   - 买入价格 > 涨停价，失败
   - 卖出价格 < 跌停价，失败

5. **T+1/T+0规则**：
   - 股票T+1：当日买入不可卖出
   - ETF T+0：当日买入可卖出（通过代码前缀判断，5开头为ETF）

#### 6.1.2 核心实现

```python
# trading/matching_engine.py

from datetime import datetime
from typing import Optional, Dict
from .order import Order, OrderStatus, OrderSide, OrderType
from .commission import CommissionCalculator
from .slippage import SlippageModel
from ..core.context import Context

class MatchingEngine:
    """撮合引擎"""
    
    def __init__(self, context: Context, config: dict):
        self.context = context
        self.config = config
        
        # 手续费计算器
        self.commission_calc = CommissionCalculator(config.get('commission', {}))
        
        # 滑点模型
        self.slippage_model = SlippageModel(config.get('slippage', {}))
    
    def match_orders(self, dt: datetime):
        """撮合当前所有未成交订单"""
        order_manager = self.context.order_manager
        
        # 获取所有OPEN状态的订单
        open_orders = order_manager.get_open_orders()
        
        for order in open_orders:
            self._try_match_order(order, dt)
    
    def _try_match_order(self, order: Order, dt: datetime):
        """尝试撮合单个订单"""
        # 检查停牌
        if self._is_suspended(order.symbol, dt):
            order.reject("标的停牌")
            self.context.logger.info(f"订单 {order.id} 拒绝：{order.symbol} 停牌")
            return
        
        # 获取价格数据
        price_data = self._get_price_data(order.symbol, dt)
        if price_data is None:
            self.context.logger.warning(f"无法获取 {order.symbol} 价格数据，跳过撮合")
            return
        
        # 确定撮合价格
        match_price = self._determine_match_price(order, price_data)
        if match_price is None:
            # 限价单无法成交
            return
        
        # 检查涨跌停
        if not self._check_limit_price(order, match_price, dt):
            order.reject("触及涨跌停")
            self.context.logger.info(f"订单 {order.id} 拒绝：触及涨跌停")
            return
        
        # 应用滑点
        slippage = self.slippage_model.calculate(order, match_price)
        if order.side == OrderSide.BUY:
            final_price = match_price + slippage
        else:
            final_price = match_price - slippage
        
        # 计算手续费
        commission = self.commission_calc.calculate(order, final_price)
        
        # 检查资金/持仓是否足够
        if not self._check_sufficiency(order, final_price, commission):
            order.reject("资金/持仓不足")
            self.context.logger.warning(f"订单 {order.id} 拒绝：资金/持仓不足")
            return
        
        # 执行成交
        self._execute_order(order, final_price, commission, dt)
    
    def _determine_match_price(
        self,
        order: Order,
        price_data: Dict
    ) -> Optional[float]:
        """确定撮合价格"""
        current_price = price_data.get('current_price')
        ask1 = price_data.get('ask1')
        bid1 = price_data.get('bid1')
        
        if order.order_type == OrderType.MARKET:
            # 市价单
            if order.side == OrderSide.BUY:
                # 买入：优先使用ask1，否则使用current_price
                return ask1 if ask1 else current_price
            else:
                # 卖出：优先使用bid1，否则使用current_price
                return bid1 if bid1 else current_price
        
        else:
            # 限价单
            limit_price = order.limit_price
            
            if order.side == OrderSide.BUY:
                # 买入：限价 >= ask1（或current_price），才能成交
                reference_price = ask1 if ask1 else current_price
                if limit_price >= reference_price:
                    return limit_price
                else:
                    return None  # 无法成交
            else:
                # 卖出：限价 <= bid1（或current_price），才能成交
                reference_price = bid1 if bid1 else current_price
                if limit_price <= reference_price:
                    return limit_price
                else:
                    return None  # 无法成交
    
    def _check_limit_price(
        self,
        order: Order,
        price: float,
        dt: datetime
    ) -> bool:
        """检查涨跌停"""
        # 获取涨跌停价格
        limit_prices = self.context.price_tool.get_limit_price(
            order.symbol,
            dt.strftime('%Y-%m-%d')
        )
        
        if not limit_prices:
            # 无涨跌停数据，放行
            return True
        
        high_limit = limit_prices.get('high_limit')
        low_limit = limit_prices.get('low_limit')
        
        # 买入：不能超过涨停价
        if order.side == OrderSide.BUY:
            if high_limit and price > high_limit:
                return False
        # 卖出：不能低于跌停价
        else:
            if low_limit and price < low_limit:
                return False
        
        return True
    
    def _check_sufficiency(
        self,
        order: Order,
        price: float,
        commission: float
    ) -> bool:
        """检查资金/持仓是否足够"""
        portfolio = self.context.portfolio
        
        if order.side == OrderSide.BUY:
            # 买入：检查现金
            total_cost = price * order.amount + commission
            return portfolio.cash >= total_cost
        else:
            # 卖出：检查持仓
            position = self.context.position_manager.get_position(order.symbol)
            if not position:
                return False
            
            # 检查T+1规则
            if self._is_t_plus_1(order.symbol):
                # 股票T+1，检查可用数量
                return position.available_amount >= order.amount
            else:
                # T+0，检查总数量
                return position.total_amount >= order.amount
    
    def _execute_order(
        self,
        order: Order,
        price: float,
        commission: float,
        dt: datetime
    ):
        """执行订单成交"""
        order.fill(price, commission, dt)
        
        # 更新账户
        portfolio = self.context.portfolio
        position_manager = self.context.position_manager
        
        if order.side == OrderSide.BUY:
            # 买入：减少现金，增加持仓
            total_cost = price * order.amount + commission
            portfolio.cash -= total_cost
            
            position_manager.increase_position(
                order.symbol,
                order.amount,
                price,
                commission,
                dt
            )
            
            self.context.logger.info(
                f"订单成交 - 买入 {order.symbol} {order.amount}股 "
                f"@{price:.2f} 手续费{commission:.2f}"
            )
        else:
            # 卖出：增加现金，减少持仓
            total_value = price * order.amount - commission
            portfolio.cash += total_value
            
            pnl = position_manager.decrease_position(
                order.symbol,
                order.amount,
                price,
                commission,
                dt
            )
            
            self.context.logger.info(
                f"订单成交 - 卖出 {order.symbol} {order.amount}股 "
                f"@{price:.2f} 手续费{commission:.2f} 盈亏{pnl:.2f}"
            )
        
        # 记录成交
        self.context.order_manager.add_filled_order(order)
    
    def settle(self):
        """每日收盘结算"""
        self.context.logger.info("开始每日结算")
        
        # 更新所有持仓市值
        position_manager = self.context.position_manager
        for position in position_manager.get_all_positions():
            # 获取收盘价
            close_price = self._get_close_price(position.symbol)
            if close_price:
                position.update_price(close_price)
        
        # 更新账户总值
        portfolio = self.context.portfolio
        total_value = portfolio.cash + sum(
            pos.market_value for pos in position_manager.get_all_positions()
        )
        portfolio.total_value = total_value
        
        # 更新持仓的可用数量（T+1处理）
        for position in position_manager.get_all_positions():
            if self._is_t_plus_1(position.symbol):
                # 今日买入的明日可卖
                position.available_amount = position.total_amount
        
        self.context.logger.info(f"结算完成 - 总资产: {total_value:.2f}")
    
    def _is_suspended(self, symbol: str, dt: datetime) -> bool:
        """判断是否停牌"""
        return self.context.price_tool.is_suspended(
            symbol,
            dt.strftime('%Y-%m-%d')
        )
    
    def _is_t_plus_1(self, symbol: str) -> bool:
        """判断是否T+1交易"""
        # 简化：ETF代码通常5开头为T+0，其他为T+1
        return not symbol.startswith('5')
    
    def _get_price_data(self, symbol: str, dt: datetime) -> Optional[Dict]:
        """获取价格数据"""
        return self.context.price_tool.get_price(
            symbol,
            dt,
            self.context.frequency
        )
    
    def _get_close_price(self, symbol: str) -> Optional[float]:
        """获取当日收盘价"""
        dt = self.context.current_dt
        price_data = self._get_price_data(symbol, dt)
        if price_data:
            return price_data.get('current_price')
        return None
```

---

### 6.2 滑点模型

```python
# trading/slippage.py

from typing import Dict
from .order import Order

class SlippageModel:
    """滑点模型"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.type = config.get('type', 'fixed')  # 目前仅支持'fixed'
        self.rate = config.get('rate', 0.001)    # 固定滑点率
    
    def calculate(self, order: Order, price: float) -> float:
        """计算滑点"""
        if self.type == 'fixed':
            return self._fixed_slippage(price)
        else:
            return 0
    
    def _fixed_slippage(self, price: float) -> float:
        """固定滑点"""
        return price * self.rate
```

---

### 6.3 手续费计算

```python
# trading/commission.py

from typing import Dict
from .order import Order, OrderSide

class CommissionCalculator:
    """手续费计算器"""
    
    def __init__(self, config: Dict):
        # 默认费率（股票）
        self.buy_commission = config.get('buy_commission', 0.0002)
        self.sell_commission = config.get('sell_commission', 0.0002)
        self.buy_tax = config.get('buy_tax', 0.0)
        self.sell_tax = config.get('sell_tax', 0.001)
        self.min_commission = config.get('min_commission', 5.0)
    
    def calculate(self, order: Order, price: float) -> float:
        """计算手续费"""
        total_value = price * order.amount
        
        if order.side == OrderSide.BUY:
            commission = total_value * self.buy_commission
            tax = total_value * self.buy_tax
        else:
            commission = total_value * self.sell_commission
            tax = total_value * self.sell_tax
        
        # 佣金不足最小值时，按最小值收取
        commission = max(commission, self.min_commission)
        
        return commission + tax
```

---

## 7. 时间与调度系统

### 7.1 时间推进策略

#### 7.1.1 回测模式

- **日频回测**：
  - 遍历交易日列表
  - 每日调用：before_trading → handle_bar → 撮合 → after_trading → 结算

- **分钟频回测**：
  - 遍历交易日
  - 每日遍历分钟时间点（09:30-11:30, 13:00-15:00）
  - 每分钟调用：handle_bar → 撮合

- **Tick频回测**：
  - 遍历交易日
  - 每日遍历Tick时间点（3秒间隔）
  - 每个Tick调用：handle_bar → 撮合

#### 7.1.2 模拟盘模式

- **实时驱动**：
  - 使用系统时钟
  - 判断当前时间点应执行的事件
  - 使用sleep精确控制调度频率

### 7.2 交易时段配置

```yaml
# configs/default.yaml

trading_hours:
  morning:
    start: "09:30:00"
    end: "11:30:00"
  afternoon:
    start: "13:00:00"
    end: "15:00:00"
  
  # 特殊事件时间点
  before_trading: "09:25:00"
  after_trading: "15:01:00"

# 频率配置
frequency: daily  # daily | minute | tick
```

---

## 8. 状态管理与持久化

### 8.1 设计目标

- 支持暂停/恢复运行
- 保存完整状态（账户、持仓、订单、用户数据）
- 粒度：每日收盘后自动保存

### 8.2 核心实现

```python
# utils/serializer.py

import pickle
import os
from datetime import datetime
from typing import Optional
from ..core.context import Context

class StateSerializer:
    """状态序列化器"""
    
    def __init__(self, context: Context, save_dir: str = '.states'):
        self.context = context
        self.save_dir = save_dir
        os.makedirs(save_dir, exist_ok=True)
    
    def save(self, tag: Optional[str] = None):
        """保存当前状态"""
        # 生成文件名
        if tag is None:
            tag = self.context.current_dt.strftime('%Y%m%d')
        
        file_path = os.path.join(
            self.save_dir,
            f"{self.context.strategy_name}_{tag}.pkl"
        )
        
        # 收集状态
        state = {
            'context': {
                'mode': self.context.mode,
                'strategy_name': self.context.strategy_name,
                'start_date': self.context.start_date,
                'end_date': self.context.end_date,
                'current_dt': self.context.current_dt,
                'frequency': self.context.frequency,
                'config': self.context.config,
            },
            'portfolio': self.context.portfolio,
            'positions': self.context.position_manager.get_all_positions(),
            'orders': self.context.order_manager.get_all_orders(),
            'user_data': self.context.user_data,
            'timestamp': datetime.now().isoformat()
        }
        
        # 序列化
        with open(file_path, 'wb') as f:
            pickle.dump(state, f)
        
        self.context.logger.info(f"状态已保存到 {file_path}")
    
    def load(self, file_path: str):
        """加载状态"""
        with open(file_path, 'rb') as f:
            state = pickle.load(f)
        
        # 恢复状态
        context_data = state['context']
        self.context.mode = context_data['mode']
        self.context.strategy_name = context_data['strategy_name']
        self.context.start_date = context_data['start_date']
        self.context.end_date = context_data['end_date']
        self.context.current_dt = context_data['current_dt']
        self.context.frequency = context_data['frequency']
        self.context.config = context_data['config']
        
        # 恢复账户
        self.context.portfolio = state['portfolio']
        
        # 恢复持仓
        self.context.position_manager.restore_positions(state['positions'])
        
        # 恢复订单
        self.context.order_manager.restore_orders(state['orders'])
        
        # 恢复用户数据
        self.context.user_data = state['user_data']
        
        self.context.logger.info(f"状态已从 {file_path} 加载")
        self.context.logger.info(f"保存时间: {state['timestamp']}")
```

---

## 9. 回测与模拟盘模式

### 9.1 模式切换

#### 9.1.1 配置驱动

```yaml
# configs/backtest.yaml
mode: backtest
frequency: daily  # daily | minute | tick
start_date: "2023-01-01"
end_date: "2023-12-31"
initial_cash: 1000000

matching:
  slippage:
    type: fixed
    rate: 0.001
  commission:
    buy_commission: 0.0002
    sell_commission: 0.0002
    sell_tax: 0.001
    min_commission: 5.0

logging:
  level: INFO
  file: logs/backtest.log
```

```yaml
# configs/simulation.yaml
mode: simulation
frequency: minute  # daily | minute | tick
initial_cash: 1000000

matching:
  slippage:
    type: fixed
    rate: 0.001
  commission:
    buy_commission: 0.0002
    sell_commission: 0.0002
    sell_tax: 0.001
    min_commission: 5.0

logging:
  level: INFO
  file: logs/simulation.log
```

#### 9.1.2 使用示例

```python
from stock_api_sdk import StockAPIClient
from quant_framework import Engine
from quant_framework.data_tools.examples import (
    APICalendarTool,
    APIPriceTool,
    APIBenchmarkTool
)
from my_strategy import MyStrategy

# 初始化API客户端
api_client = StockAPIClient(
    base_url="http://your-api-server/api/v1",
    api_key="your_api_key"
)

# 创建数据工具
calendar_tool = APICalendarTool(api_client)
price_tool = APIPriceTool(api_client)
benchmark_tool = APIBenchmarkTool(api_client)

# 回测
engine_bt = Engine(config_path='configs/backtest.yaml')
engine_bt.run(
    MyStrategy,
    calendar_tool=calendar_tool,
    price_tool=price_tool,
    benchmark_tool=benchmark_tool,
    start_date='2023-01-01',
    end_date='2023-12-31'
)

# 模拟盘（同一策略代码）
engine_sim = Engine(config_path='configs/simulation.yaml')
engine_sim.run(
    MyStrategy,
    calendar_tool=calendar_tool,
    price_tool=price_tool,
    benchmark_tool=benchmark_tool
)
```

---

## 10. 可视化与报告

### 10.1 绩效分析

```python
# analysis/performance.py

import pandas as pd
import numpy as np
from typing import Dict
from ..core.context import Context

class PerformanceAnalyzer:
    """绩效分析器"""
    
    def __init__(self, context: Context):
        self.context = context
    
    def calculate_metrics(self) -> Dict:
        """计算绩效指标"""
        # 从账户历史记录计算
        portfolio_history = self._get_portfolio_history()
        
        if len(portfolio_history) == 0:
            return {}
        
        returns = self._calculate_returns(portfolio_history)
        
        metrics = {
            'total_return': self._total_return(returns),
            'annual_return': self._annual_return(returns),
            'sharpe_ratio': self._sharpe_ratio(returns),
            'max_drawdown': self._max_drawdown(portfolio_history),
            'win_rate': self._win_rate(),
            'profit_factor': self._profit_factor()
        }
        
        return metrics
    
    def _get_portfolio_history(self) -> pd.DataFrame:
        """获取账户历史记录"""
        # 需要在账户管理器中记录每日总值
        # 这里假设有记录
        if not hasattr(self.context.portfolio, 'history'):
            return pd.DataFrame()
        
        return pd.DataFrame(self.context.portfolio.history)
    
    def _calculate_returns(self, portfolio_history: pd.DataFrame) -> pd.Series:
        """计算收益率序列"""
        values = portfolio_history['total_value']
        returns = values.pct_change().fillna(0)
        return returns
    
    def _total_return(self, returns: pd.Series) -> float:
        """总收益率"""
        return (1 + returns).prod() - 1
    
    def _annual_return(self, returns: pd.Series) -> float:
        """年化收益率"""
        days = len(returns)
        if days == 0:
            return 0
        total_return = self._total_return(returns)
        return (1 + total_return) ** (252 / days) - 1
    
    def _sharpe_ratio(self, returns: pd.Series, risk_free_rate: float = 0.03) -> float:
        """夏普比率"""
        if len(returns) == 0 or returns.std() == 0:
            return 0
        excess_return = returns.mean() * 252 - risk_free_rate
        return excess_return / (returns.std() * np.sqrt(252))
    
    def _max_drawdown(self, portfolio_history: pd.DataFrame) -> float:
        """最大回撤"""
        values = portfolio_history['total_value']
        cumulative = values
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        return drawdown.min()
    
    def _win_rate(self) -> float:
        """胜率"""
        closed_trades = self._get_closed_trades()
        if len(closed_trades) == 0:
            return 0
        wins = sum(1 for t in closed_trades if t['pnl'] > 0)
        return wins / len(closed_trades)
    
    def _profit_factor(self) -> float:
        """盈亏比"""
        closed_trades = self._get_closed_trades()
        if len(closed_trades) == 0:
            return 0
        
        total_profit = sum(t['pnl'] for t in closed_trades if t['pnl'] > 0)
        total_loss = abs(sum(t['pnl'] for t in closed_trades if t['pnl'] < 0))
        
        if total_loss == 0:
            return float('inf')
        return total_profit / total_loss
    
    def _get_closed_trades(self) -> list:
        """获取已平仓交易"""
        # 从订单管理器获取成交订单，配对买卖
        filled_orders = self.context.order_manager.get_filled_orders()
        
        # 简化实现：配对同一标的的买卖单
        trades = []
        buy_orders = {}
        
        for order in filled_orders:
            if order.side.value == 'buy':
                if order.symbol not in buy_orders:
                    buy_orders[order.symbol] = []
                buy_orders[order.symbol].append(order)
            else:
                # 卖出单，匹配买入单
                if order.symbol in buy_orders and len(buy_orders[order.symbol]) > 0:
                    buy_order = buy_orders[order.symbol].pop(0)
                    pnl = (order.filled_price - buy_order.filled_price) * order.amount - order.commission - buy_order.commission
                    trades.append({
                        'symbol': order.symbol,
                        'pnl': pnl
                    })
        
        return trades
```

---

### 10.2 可视化

```python
# analysis/visualizer.py

import matplotlib.pyplot as plt
import pandas as pd
from ..core.context import Context

class Visualizer:
    """可视化工具"""
    
    def __init__(self, context: Context):
        self.context = context
    
    def plot_equity_curve(self, save_path: str = None):
        """绘制权益曲线"""
        history = self._get_portfolio_history()
        
        if len(history) == 0:
            print("无历史数据可绘制")
            return
        
        plt.figure(figsize=(12, 6))
        plt.plot(history.index, history['total_value'], label='Strategy')
        
        # 如果有基准，绘制基准
        benchmark_history = self._get_benchmark_history()
        if len(benchmark_history) > 0:
            plt.plot(benchmark_history.index, benchmark_history['value'], label='Benchmark')
        
        plt.title('Equity Curve')
        plt.xlabel('Date')
        plt.ylabel('Portfolio Value')
        plt.legend()
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path)
        else:
            plt.show()
    
    def plot_drawdown(self, save_path: str = None):
        """绘制回撤曲线"""
        history = self._get_portfolio_history()
        
        if len(history) == 0:
            print("无历史数据可绘制")
            return
        
        values = history['total_value']
        running_max = values.expanding().max()
        drawdown = (values - running_max) / running_max
        
        plt.figure(figsize=(12, 6))
        plt.fill_between(drawdown.index, drawdown.values, 0, alpha=0.3, color='red')
        plt.title('Drawdown')
        plt.xlabel('Date')
        plt.ylabel('Drawdown')
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path)
        else:
            plt.show()
    
    def _get_portfolio_history(self) -> pd.DataFrame:
        """获取账户历史"""
        if not hasattr(self.context.portfolio, 'history'):
            return pd.DataFrame()
        
        df = pd.DataFrame(self.context.portfolio.history)
        if 'date' in df.columns:
            df['date'] = pd.to_datetime(df['date'])
            df.set_index('date', inplace=True)
        return df
    
    def _get_benchmark_history(self) -> pd.DataFrame:
        """获取基准历史"""
        # 需要在运行过程中记录基准价格
        # 暂时返回空
        return pd.DataFrame()
```

---

### 10.3 报告生成

```python
# analysis/report.py

from jinja2 import Template
from ..core.context import Context
from .performance import PerformanceAnalyzer
from .visualizer import Visualizer

class ReportGenerator:
    """报告生成器"""
    
    def __init__(self, context: Context):
        self.context = context
        self.analyzer = PerformanceAnalyzer(context)
        self.visualizer = Visualizer(context)
    
    def generate_html_report(self, output_path: str):
        """生成HTML报告"""
        # 计算指标
        metrics = self.analyzer.calculate_metrics()
        
        # 生成图表
        self.visualizer.plot_equity_curve(save_path='temp_equity.png')
        self.visualizer.plot_drawdown(save_path='temp_drawdown.png')
        
        # 渲染模板
        template = self._load_template()
        html = template.render(
            strategy_name=self.context.strategy_name,
            mode=self.context.mode,
            frequency=self.context.frequency,
            start_date=self.context.start_date,
            end_date=self.context.end_date,
            metrics=metrics,
            equity_chart='temp_equity.png',
            drawdown_chart='temp_drawdown.png'
        )
        
        # 保存
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html)
        
        self.context.logger.info(f"报告已生成: {output_path}")
    
    def _load_template(self) -> Template:
        """加载HTML模板"""
        template_str = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>{{ strategy_name }} - 回测报告</title>
            <meta charset="utf-8">
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                h1 { color: #333; }
                .info { margin: 10px 0; }
                .metric { margin: 10px 0; }
                .chart { margin: 20px 0; }
                table { border-collapse: collapse; width: 100%; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #4CAF50; color: white; }
            </style>
        </head>
        <body>
            <h1>{{ strategy_name }} - 策略报告</h1>
            
            <h2>基本信息</h2>
            <div class="info"><strong>模式:</strong> {{ mode }}</div>
            <div class="info"><strong>频率:</strong> {{ frequency }}</div>
            <div class="info"><strong>时间范围:</strong> {{ start_date }} 至 {{ end_date }}</div>
            
            <h2>绩效指标</h2>
            <table>
                <tr>
                    <th>指标</th>
                    <th>数值</th>
                </tr>
                {% for key, value in metrics.items() %}
                <tr>
                    <td>{{ key }}</td>
                    <td>{{ "%.2f%%"|format(value * 100) if value != float('inf') else '∞' }}</td>
                </tr>
                {% endfor %}
            </table>
            
            <h2>权益曲线</h2>
            <img src="{{ equity_chart }}" class="chart" width="800">
            
            <h2>回撤曲线</h2>
            <img src="{{ drawdown_chart }}" class="chart" width="800">
        </body>
        </html>
        """
        return Template(template_str)
```

---

## 11. 扩展性设计

### 11.1 插件系统

```python
# plugins/base.py

from abc import ABC, abstractmethod
from ..core.context import Context

class Plugin(ABC):
    """插件基类"""
    
    def __init__(self, context: Context):
        self.context = context
    
    @abstractmethod
    def on_init(self):
        """初始化时调用"""
        pass
    
    def on_before_trading(self):
        """盘前调用"""
        pass
    
    def on_after_trading(self):
        """盘后调用"""
        pass
    
    def on_bar(self):
        """每个bar调用"""
        pass
```

示例插件：风险控制

```python
# plugins/risk_control.py

from .base import Plugin
from ..trading.order import OrderSide

class RiskControlPlugin(Plugin):
    """风险控制插件"""
    
    def __init__(self, context, max_position_ratio=0.3):
        super().__init__(context)
        self.max_position_ratio = max_position_ratio
    
    def on_init(self):
        self.context.logger.info("风险控制插件已初始化")
    
    def on_bar(self):
        """检查仓位是否超限"""
        portfolio = self.context.portfolio
        
        for position in self.context.position_manager.get_all_positions():
            ratio = position.market_value / portfolio.total_value
            if ratio > self.max_position_ratio:
                # 触发风控：平仓部分持仓
                excess_amount = int(
                    (ratio - self.max_position_ratio) * 
                    portfolio.total_value / position.price
                )
                
                # 提交卖出订单
                self.context.order_manager.submit_order(
                    position.symbol,
                    -excess_amount,
                    order_type='market'
                )
                
                self.context.logger.warning(
                    f"风控触发: {position.symbol} 仓位超限，"
                    f"减仓 {excess_amount} 股"
                )
```

---

## 12. 实施路线图

### 12.1 阶段一：核心框架（2周）

**目标**：搭建可运行的最小框架

- [x] 实现Context、Engine、Scheduler
- [x] 实现TimeManager
- [x] 实现数据工具接口定义
- [x] 实现订单、持仓、账户模型
- [x] 实现简单的撮合引擎（日频回测）
- [ ] 编写示例策略并测试

### 12.2 阶段二：撮合增强（1周）

**目标**：完善撮合机制

- [x] 实现限价单和市价单撮合逻辑
- [x] 实现滑点模型
- [x] 实现手续费计算
- [x] 实现涨跌停检查
- [x] 实现T+1/T+0规则
- [ ] 分钟频、Tick频回测支持

### 12.3 阶段三：数据工具示例（1周）

**目标**：提供数据工具参考实现

- [x] 实现基于Stock API的日历工具
- [x] 实现基于Stock API的价格工具
- [x] 实现基于Stock API的基准工具
- [ ] 编写数据工具使用文档
- [ ] 测试数据工具与框架集成

### 12.4 阶段四：状态管理（1周）

**目标**：支持暂停/恢复

- [x] 实现StateSerializer
- [x] 实现状态序列化/反序列化
- [ ] 实现自动保存点
- [ ] 测试恢复功能

### 12.5 阶段五：模拟盘支持（1周）

**目标**：支持模拟盘模式

- [x] 实现实时调度逻辑
- [x] 实现模拟盘数据获取
- [x] 实现模拟盘撮合
- [ ] 测试模拟盘模式运行

### 12.6 阶段六：分析与可视化（1周）

**目标**：完善分析工具

- [x] 实现PerformanceAnalyzer
- [x] 实现Visualizer
- [x] 实现ReportGenerator
- [ ] 生成完整回测报告

### 12.7 阶段七：文档与示例（1周）

**目标**：完善文档

- [ ] 编写用户手册
- [ ] 编写API文档
- [ ] 编写数据工具开发指南
- [ ] 提供更多策略示例

### 12.8 阶段八：测试与优化（1周）

**目标**：提高稳定性

- [ ] 单元测试覆盖
- [ ] 集成测试
- [ ] 性能优化
- [ ] Bug修复

---

## 13. 配置示例

### 13.1 完整配置文件

```yaml
# configs/default.yaml

# 运行模式
mode: backtest  # backtest | simulation

# 策略基本信息
strategy_name: "MyStrategy"
frequency: daily  # daily | minute | tick

# 回测时间范围
start_date: "2023-01-01"
end_date: "2023-12-31"

# 初始资金
initial_cash: 1000000

# 撮合配置
matching:
  slippage:
    type: fixed  # 固定滑点
    rate: 0.001
  
  commission:
    buy_commission: 0.0002
    sell_commission: 0.0002
    buy_tax: 0.0
    sell_tax: 0.001
    min_commission: 5.0

# 交易时段
trading_hours:
  morning:
    start: "09:30:00"
    end: "11:30:00"
  afternoon:
    start: "13:00:00"
    end: "15:00:00"
  before_trading: "09:25:00"
  after_trading: "15:01:00"

# 基准
benchmark: "000300"  # 沪深300

# 状态保存
state:
  auto_save: true
  save_dir: .states

# 日志
logging:
  level: INFO
  file: logs/strategy.log

# 报告
report:
  output_dir: reports
  auto_generate: true
```

---

## 14. 策略示例

### 14.1 简单均线策略

```python
# examples/simple_ma.py

from quant_framework.strategy import Strategy
from quant_framework import Engine
from stock_api_sdk import StockAPIClient
from quant_framework.data_tools.examples import (
    APICalendarTool,
    APIPriceTool,
    APIBenchmarkTool
)

class SimpleMAStrategy(Strategy):
    """简单双均线策略"""
    
    def initialize(self, context):
        """初始化"""
        context.set('ma_short', 5)
        context.set('ma_long', 20)
        context.set('symbol', '000001')
        context.set('price_history', [])
    
    def handle_bar(self, context, data):
        """每个bar执行"""
        symbol = context.get('symbol')
        
        # 获取当前价格（通过数据工具）
        price_data = context.price_tool.get_price(
            symbol,
            context.current_dt,
            context.frequency
        )
        
        if price_data is None:
            return
        
        current_price = price_data['current_price']
        
        # 更新价格历史
        price_history = context.get('price_history')
        price_history.append(current_price)
        
        # 保持最近ma_long个价格
        ma_long = context.get('ma_long')
        if len(price_history) > ma_long:
            price_history = price_history[-ma_long:]
            context.set('price_history', price_history)
        
        # 计算均线
        if len(price_history) < ma_long:
            return
        
        ma_short_value = sum(price_history[-context.get('ma_short'):]) / context.get('ma_short')
        ma_long_value = sum(price_history) / ma_long
        
        # 获取当前持仓
        position = context.position_manager.get_position(symbol)
        
        # 交易逻辑
        if ma_short_value > ma_long_value:
            # 金叉：买入
            if position is None or position.total_amount == 0:
                # 计算买入数量（使用50%资金）
                cash = context.portfolio.cash
                amount = int(cash * 0.5 / current_price / 100) * 100
                
                if amount > 0:
                    context.order_manager.submit_order(
                        symbol,
                        amount,
                        order_type='market'
                    )
                    context.logger.info(f"金叉买入信号：{symbol} {amount}股")
        
        elif ma_short_value < ma_long_value:
            # 死叉：卖出
            if position and position.total_amount > 0:
                context.order_manager.submit_order(
                    symbol,
                    -position.total_amount,
                    order_type='market'
                )
                context.logger.info(f"死叉卖出信号：{symbol} {position.total_amount}股")

if __name__ == '__main__':
    # 初始化API客户端
    api_client = StockAPIClient(
        base_url="http://your-api-server/api/v1",
        api_key="your_api_key"
    )
    
    # 创建数据工具
    calendar_tool = APICalendarTool(api_client)
    price_tool = APIPriceTool(api_client)
    benchmark_tool = APIBenchmarkTool(api_client)
    
    # 创建引擎
    engine = Engine(config_path='configs/backtest.yaml')
    
    # 运行策略
    engine.run(
        SimpleMAStrategy,
        calendar_tool=calendar_tool,
        price_tool=price_tool,
        benchmark_tool=benchmark_tool,
        start_date='2023-01-01',
        end_date='2023-12-31',
        strategy_name='SimpleMA'
    )
```

---

## 15. 总结

本文档详细设计了一个**专注于交易逻辑、数据完全解耦**的量化交易框架，核心特点包括：

### 15.1 核心优势

1. **数据完全解耦**
   - 框架不自带任何数据获取实现
   - 仅定义数据工具接口规范
   - 用户根据自己的数据源实现接口
   - 框架只关心交易必需的数据：交易日历、成交价格、涨跌停价、基准行情

2. **回测/模拟统一**
   - 同一策略代码无缝切换
   - 配置驱动模式切换
   - 数据工具保持一致

3. **精简撮合机制**
   - 仅支持限价单和市价单
   - 使用ask1/bid1+滑点撮合
   - 回退机制：无五档数据时使用current_price
   - 涨跌停检查
   - T+1/T+0自动处理

4. **多频率支持**
   - 日频：每日一次
   - 分钟频：每分钟一次
   - Tick频：每3秒一次

5. **状态可持久化**
   - 支持暂停/恢复
   - 每日自动保存
   - 完整状态恢复

6. **事件驱动架构**
   - 清晰的生命周期钩子
   - initialize → before_trading → handle_bar → after_trading → on_end

### 15.2 使用流程

1. **实现数据工具**
   - 继承CalendarTool、PriceTool、BenchmarkTool
   - 根据自己的数据源实现接口方法
   - 可参考examples中的API实现

2. **编写策略**
   - 继承Strategy基类
   - 实现生命周期钩子
   - 使用context访问账户、持仓、订单
   - 使用数据工具获取必要数据

3. **配置运行参数**
   - 编写配置文件（YAML）
   - 设置模式、频率、资金、手续费等

4. **运行策略**
   - 创建Engine实例
   - 注入数据工具
   - 调用run方法

5. **查看报告**
   - 自动生成HTML报告
   - 包含绩效指标、权益曲线、回撤曲线

### 15.3 下一步工作

建议按照实施路线图逐步开发：

1. **优先级1**：完成核心框架和撮合机制
2. **优先级2**：提供数据工具示例实现
3. **优先级3**：完善状态管理和模拟盘
4. **优先级4**：增强分析与可视化
5. **优先级5**：编写文档和示例

### 15.4 设计哲学

本框架遵循**Unix哲学**：

- **Do One Thing Well**：专注于交易逻辑，不涉及数据获取
- **Composition Over Inheritance**：通过组合数据工具，而非继承复杂类
- **Separation of Concerns**：数据、策略、框架三者完全分离
- **Convention Over Configuration**：合理的默认配置，减少配置负担

框架的核心价值在于**提供一个干净、可靠的交易引擎**，让用户可以专注于策略开发，而不必担心底层实现细节。

---

**文档版本**: 2.0.0  
**最后更新**: 2025年10月  
**状态**: 详细设计完成